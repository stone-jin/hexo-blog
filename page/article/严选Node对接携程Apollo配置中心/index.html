<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>严选Node对接携程Apollo配置中心 | 大米小米的博客</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="typescript, nodejs, javascript, webpack, 前端, 全栈开发"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.fedfans.com/page/article/严选Node对接携程Apollo配置中心/index.html"><link rel="icon" type="image/png" href="https://user-images.githubusercontent.com/6525544/44798832-169c4280-abe5-11e8-8b7c-618aee212586.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="大米小米的博客"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f1e4c915dd718aa486135ab51167ad12";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://520stone-blog.oss-cn-beijing.aliyuncs.com/blog_fedfans/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="大米小米的博客" alt="大米小米的博客" style="color:#fff;text-decoration:none">大米小米的博客</a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557386231926-fb7107ea-fbea-41fd-8e42-c334fbc68547.png" alt="严选Node对接携程Apollo配置中心"></div><header class="post__info"><h1 class="post__title">严选Node对接携程Apollo配置中心</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/stone-jin">金炳</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-05-09</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Node/">Node</a></li><li class="mark__item"><a href="/tags/配置中心/">配置中心</a></li><li class="mark__item"><a href="/tags/Apollo/">Apollo</a></li><li class="mark__item"><a href="/tags/基建/">基建</a></li></ul></div></div></header><div class="post__content"><h1 id="严选Node对接携程Apollo配置中心"><a href="#严选Node对接携程Apollo配置中心" class="headerlink" title="严选Node对接携程Apollo配置中心"></a>严选Node对接携程Apollo配置中心</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557414849981-a5f61a71-4720-4f78-8801-e1e7d6068a5e.png" alt=""></p><p><a name="s38lq"></a></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p><a name="TF7Fh"></a></p><h3 id="1-1-对接携程配置中心"><a href="#1-1-对接携程配置中心" class="headerlink" title="1.1 对接携程配置中心"></a>1.1 对接携程配置中心</h3><p>因为在给Node支持携程Apollo对接，携程Apollo是一个配置中心的解决方案，配置中心又是服务端的一个比较常用的功能。网上有人开发了一个node的apollo的sdk：<a href="https://github.com/Quinton/node-apollo" target="_blank" rel="noopener">https://github.com/Quinton/node-apollo</a>，查看代码和介绍发现并没有实现配置动态变化的时候，如何下发到应用内，其内部是主要是拉取config配置和生成对应的配置，相当于如何将远程的配置拉过来生成一份本地的配置。</p><p><a name="OPQsV"></a></p><h3 id="1-2-需求"><a href="#1-2-需求" class="headerlink" title="1.2 需求"></a>1.2 需求</h3><p>那么我们的需求是：能跟java的客户端一样，当应用起来的时候，我们能从配置中心拉取当前新的配置文件，如果跟配置中心网络是断开的，则我们先使用本地的配置文件。如果连接上后，当配置中心上，我们更新了新的配置文件的话，需要实时同步到应用程序内部确保应用程序用的是新的配置文件。</p><p><a name="XrMJN"></a></p><h3 id="1-3-官方客户端设计思路"><a href="#1-3-官方客户端设计思路" class="headerlink" title="1.3 官方客户端设计思路"></a>1.3 官方客户端设计思路</h3><p>官方总体对于 客户端设计思想如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557386231926-fb7107ea-fbea-41fd-8e42-c334fbc68547.png#align=left&amp;display=inline&amp;height=738&amp;name=image.png&amp;originHeight=738&amp;originWidth=1520&amp;size=132695&amp;status=done&amp;width=1520" alt="image.png"></p><p>上图也就跟我们的需求很一样，官方描述一下Apollo客户端的实现原理：</p><ol><li>客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。（通过Http Long Polling实现）</li><li>客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。<ol><li>这是一个fallback机制，为了防止推送机制失效导致配置不更新</li><li>客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified</li><li>定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。</li></ol></li><li>客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中</li><li>客户端会把从服务端获取到的配置在本地文件系统缓存一份<ol><li>在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置</li></ol></li><li>应用程序可以从Apollo客户端获取最新的配置、订阅配置更新通知</li></ol><p><a name="Jbc5y"></a></p><h2 id="二、Http-Long-Polling"><a href="#二、Http-Long-Polling" class="headerlink" title="二、Http Long Polling"></a>二、Http Long Polling</h2><p>关于实时性，我们看到上面方案中，其实最关键的就是Http Long Polling。<br>那么Http的Long Polling是什么个原理呢？<br><a name="JsZIA"></a></p><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>长轮询(Long Polling)的服务其客户端是不做轮询的，客户端在发起一次请求后立即挂起，一直到服务器端有更新的时候，服务器才会主动推送信息到客户端。 在服务器端有更新并推送信息过来之前这个周期内，客户端不会有新的多余的请求发生，服务器端对此客户端也啥都不用干，只保留最基本的连接信息，一旦服务器有更新将推送给客户端，客户端将相应的做出处理，处理完后再重新发起下一轮请求。</p><p>大概意思：就是客户端发起了一个请求，然后服务器挂起，然后有数据返回了，则返回给客户端并断开。然后客户端重新这个操作。</p><p><a name="TxJ7Z"></a></p><h3 id="2-1-2-关注点"><a href="#2-1-2-关注点" class="headerlink" title="2.1.2 关注点"></a>2.1.2 关注点</h3><p>上面的概括中，我们需要特别关注的是：</p><ol><li>服务端会阻塞请求直到有数据传递或超时才返回；</li><li>服务端如何决定自己应不应该返回数据，最终断开这次连接。</li><li>客户端响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接；</li><li>当客户端在处理返回数据的时候，服务端可能已经有新的数据到达。</li></ol><p><a name="inWps"></a></p><h3 id="2-1-3-分析阶段"><a href="#2-1-3-分析阶段" class="headerlink" title="2.1.3 分析阶段"></a>2.1.3 分析阶段</h3><p>我们用nodejs来写个代码分析一下。</p><p><a name="jB0T1"></a></p><h4 id="2-1-3-1-关注点1"><a href="#2-1-3-1-关注点1" class="headerlink" title="2.1.3.1 关注点1"></a>2.1.3.1 关注点1</h4><p>关注点1比较好实现。<br>我们利用node来写一个延时返回的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ctx.body = <span class="string">'hello world'</span>;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><p>我们通过setTimeout延迟请求返回的时间，过了5秒后，我们再返回。<br>这个就是我们关注点一的实现。</p><p><a name="LCiIs"></a></p><h4 id="2-1-3-2-关注点2"><a href="#2-1-3-2-关注点2" class="headerlink" title="2.1.3.2 关注点2"></a>2.1.3.2 关注点2</h4><p>关注点2，就是Http long polling最关键的一步：<br>如果我们每次客户端来请求了，就直接返回，那我们的代码就变成了Polling了，就是客户端定时来调用服务端的接口以达到更新配置的情况，也就无法达到实时性的一个情况了，毕竟定时获取这个定时器是有时间的。另外还可能变成死循环，怎么说呢，因为关注点3，客户端响应处理完后，会再次发起。</p><p>错误点1：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557387429755-babe3c97-9252-436b-aae4-798a4c0fc912.png#align=left&amp;display=inline&amp;height=253&amp;name=image.png&amp;originHeight=253&amp;originWidth=671&amp;size=14777&amp;status=done&amp;width=671" alt="image.png"><br>这个时候，这种其实是Polling模式。<br>缺点：</p><ol><li>比如我们定时器是1分钟一次，如果我们在配置中心上更改的配置，要在小于等于一分钟才能收到，那就达不到准实时了。</li><li>有人会将定时器设置的比较端，比如5s钟一次，那想象一下，整个事业部这么多系统连接了配置中心，超级多的服务这么调用他，那对于配置中心压力也是够大的。而且配置中心修改，要在小于等于5s的时间才能收到，也没有准实时。</li></ol><p>错误点2：<br>没有关注Http long polling机制的条件，就是服务端如何决定自己要不要返回数据。<br>其实是依赖于客户端返回的参数的。<br>否则如果我们给的参数不对，那结果就是，我们的代码会陷入一个死循环。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557387786789-a6e5dbd5-5ac1-4a4d-894f-bc3d048bb189.png#align=left&amp;display=inline&amp;height=286&amp;name=image.png&amp;originHeight=286&amp;originWidth=687&amp;size=12168&amp;status=done&amp;width=687" alt="image.png"><br>客户端发起了请求，服务端返回了。然后客户端处理完了，然后再发起请求，服务端又立马返回了，如此反复。<br>会把配置中心搞死的。</p><p>所以这块我们用node程序来写一个模拟程序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> koa, &#123;Context&#125; <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'koa-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Event <span class="keyword">from</span> <span class="string">'events'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> queue: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/hello"</span>, <span class="keyword">async</span> (ctx: Context, next)=&gt;&#123;</span><br><span class="line">    ctx.query.num = <span class="built_in">parseInt</span>(ctx.query.num)</span><br><span class="line">    <span class="keyword">if</span>(ctx.query.num === <span class="number">-1</span> || ctx.query.num !== i)&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.body = i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> event = <span class="keyword">new</span> Event();</span><br><span class="line">        queue.push(&#123;</span><br><span class="line">            ctx,</span><br><span class="line">            event</span><br><span class="line">        &#125;);</span><br><span class="line">        ctx.socket.on(<span class="string">'close'</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"===&gt;close"</span>)</span><br><span class="line">            event.emit(<span class="string">'end'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            event.on(<span class="string">'send'</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                ctx.body = i;</span><br><span class="line">                resolve(<span class="string">'123'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            event.on(<span class="string">'end'</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                queue.filter(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">                    queue.splice(index, <span class="number">1</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                resolve(&#123;&#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/add"</span>, <span class="keyword">async</span> (ctx: Context, next)=&gt;&#123;</span><br><span class="line">    i ++;</span><br><span class="line">    <span class="built_in">console</span>.log(queue.length)</span><br><span class="line">    queue.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        item.event.emit(<span class="string">'send'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    queue = [];</span><br><span class="line">    ctx.body = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'abort'</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"====&gt;"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><p>这块我写了一个typescript的程序来描述一下。</p><p>步骤一：<br>当我们发起一个请求的时候，一般最开始我们由于不知道服务器端现在什么配置了，就会先告诉服务器端请给我来一份全部的配置文件。这时候我们的参数是 -1，此处请求是<a href="http://127.0.0.1:8000/hello?num=-1" target="_blank" rel="noopener">http://127.0.0.1:8000/hello?num=-1</a><br>然后服务端收到后，就立马返回给我们最新的配置。完全不用等待。<br>返回给我们:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>步骤二：<br>这个时候，我们应该是要拿着刚刚返回的1，去请求新的配置了，这时候我们的请求是<br><a href="http://127.0.0.1:8000/hello?num=1" target="_blank" rel="noopener">http://127.0.0.1:8000/hello?num=1</a><br>这个时候，服务端根据第14 行的条件都不满足，所以进入下一个else里面，<br>这个时候，服务端不返回，所以用postman看到的情况就是：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557388316806-e566199b-ebc7-44e7-b30a-d129878bf13d.png#align=left&amp;display=inline&amp;height=404&amp;name=image.png&amp;originHeight=404&amp;originWidth=967&amp;size=32059&amp;status=done&amp;width=967" alt="image.png"><br>这个时候，服务端就一直不返回了。<br>然后当我们发一个<br><a href="http://127.0.0.1:8000/add的接口后，由于他会去遍历整个queue里面的event进行emit。同时更新了一下i这个变量。所以这个时候，那边收到了请求后，就会去处理，同时返回给客户端，新的i。可以理解为配置的id变了。" target="_blank" rel="noopener">http://127.0.0.1:8000/add的接口后，由于他会去遍历整个queue里面的event进行emit。同时更新了一下i这个变量。所以这个时候，那边收到了请求后，就会去处理，同时返回给客户端，新的i。可以理解为配置的id变了。</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557388879586-2310730f-fe45-429f-acd5-d2459ac71e4d.png#align=left&amp;display=inline&amp;height=463&amp;name=image.png&amp;originHeight=463&amp;originWidth=645&amp;size=27287&amp;status=done&amp;width=645" alt="image.png"><br>那客户端会对返回数据做一个处理，然后发起一个新的请求，这个时候，就会带上这个返回给我们的id了。<br>新的请求地址是：<a href="http://127.0.0.1:8000?num=2，然后服务端如果这阵子没更新，又会进入下面这个状态。" target="_blank" rel="noopener">http://127.0.0.1:8000?num=2，然后服务端如果这阵子没更新，又会进入下面这个状态。</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557388979651-ec8205a9-c687-4589-b8c8-d0e639b5ff0e.png#align=left&amp;display=inline&amp;height=435&amp;name=image.png&amp;originHeight=435&amp;originWidth=982&amp;size=35872&amp;status=done&amp;width=982" alt="image.png"><br>但是这个时候，我们看到代码中我们有一个处理，就是因为客户端可能关闭掉这个请求了，或者客户端挂了，超时了等。<br>这个时候，这个时候我们需要处理客户端断开的情况，相当于客户端断开了，我们应该尽早的把资源给释放掉，防止其占用我们资源，此处我们的资源就是queue资源了。<br>所以下面的代码，就可以看到我们关闭了这些资源，减少了queue的资源的浪费，其实ctx等资源也是的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557389198502-d04f8427-53dc-4b3c-a313-1a3e30705cb6.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=338&amp;originWidth=552&amp;size=43298&amp;status=done&amp;width=552" alt="image.png"></p><p><a name="v55e0"></a></p><h4 id="2-1-3-3-关注点3"><a href="#2-1-3-3-关注点3" class="headerlink" title="2.1.3.3 关注点3"></a>2.1.3.3 关注点3</h4><p>关注点三，就是客户端层面的了，我们需要根据在请求返回后，处理一下，然后重新立马发起，而不要出现内部有什么setTimeout的情况，以及参数需要修改。</p><p><a name="7PK7U"></a></p><h4 id="2-1-3-4-关注点4"><a href="#2-1-3-4-关注点4" class="headerlink" title="2.1.3.4 关注点4"></a>2.1.3.4 关注点4</h4><p>这个事情，其实是这样的，就是为了下面这种情况<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557389534987-c37b1528-ecf4-4e9e-8e9d-5d9c1b877753.png#align=left&amp;display=inline&amp;height=308&amp;name=image.png&amp;originHeight=308&amp;originWidth=970&amp;size=26519&amp;status=done&amp;width=970" alt="image.png"><br>就是当我们在处理请求的期间，然后服务端又更新了配置，当我们处理完毕后，会立马发起请求，然后应该是立马接收到这个返回值，然后我们再开始处理返回，当处理完毕后，再发起这个请求。</p><p>然后这个时候，我们又会进入以下状态：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557388979651-ec8205a9-c687-4589-b8c8-d0e639b5ff0e.png#align=left&amp;display=inline&amp;height=330&amp;originHeight=435&amp;originWidth=982&amp;status=done&amp;width=746" alt=""></p><p><a name="S4kLA"></a></p><h3 id="2-1-4-注意点"><a href="#2-1-4-注意点" class="headerlink" title="2.1.4 注意点"></a>2.1.4 注意点</h3><p>情况一：<br>由于我们的http long polling会经过nginx，那nginx那层对于长时间没反应的请求，会帮我们做处理，所以我们要注意nginx对于long polling时间的一个设定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	// 此处发起一个long polling</span><br><span class="line"> &#125;catch(e)&#123;</span><br><span class="line">   // 情况一：如果我们的请求被nginx给断掉了，那就进入这个里面了</span><br><span class="line">   // 情况二：如果服务端挂了</span><br><span class="line">   // 所以首先我们应该确保我们用Http long polling的时候，nginx那层的时间要大于http long polling的时间</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="Fq3uV"></a></p><h2 id="三、定时获取机制"><a href="#三、定时获取机制" class="headerlink" title="三、定时获取机制"></a>三、定时获取机制</h2><p><a name="vyAG7"></a></p><h3 id="3-1-fallback机制"><a href="#3-1-fallback机制" class="headerlink" title="3.1 fallback机制"></a>3.1 fallback机制</h3><p>当推送机制出问题的时候，我们可以确保配置不更新，那样也是比较尴尬的事情，所以这个是保险丝，相当于这块会定时拉取。来保障当Http long polling出问题的时候，我们的配置也能正常工作。<br><a name="PquWG"></a></p><h3 id="3-2-304机制"><a href="#3-2-304机制" class="headerlink" title="3.2 304机制"></a>3.2 304机制</h3><p>定时拉取的时候，类似上面我们介绍的，把本地的id告诉服务端，然后服务端会告诉我们，变更了没有，如果没有变更则直接返回http code 304。那我们就不用去拿body了。这样也节约了网络body的流量。因为配置多的话，还是比较浪费，以及，服务端，可以根据id做判断是否变了，如果变了再去数据库获取，那节约对数据库的消耗。毕竟id什么的放在cache或者redis里面还是很快的。<br><a name="d2Y0V"></a></p><h3 id="3-3-时间频率"><a href="#3-3-时间频率" class="headerlink" title="3.3 时间频率"></a>3.3 时间频率</h3><p>上面官方那张图，其实写着java那边相当于5分钟拉取一次，那我们node也可以这么实现。</p><p><a name="RZCoD"></a></p><h2 id="四、实时内存机制"><a href="#四、实时内存机制" class="headerlink" title="四、实时内存机制"></a>四、实时内存机制</h2><p><a name="SRWeg"></a></p><h3 id="4-1-实时内存"><a href="#4-1-实时内存" class="headerlink" title="4.1 实时内存"></a>4.1 实时内存</h3><p>其实我们网上搜到的那个看似对接apollo的sdk：<a href="https://github.com/Quinton/node-apollo" target="_blank" rel="noopener">https://github.com/Quinton/node-apollo</a>，其实Http long polling是没有的，也没法做到实时内存机制。<br>这个相当于，当我们感知到配置更新的时候，我们应该是能同步到node的应用中，当controller或者service拿取的时候，我们应该是拿到新的配置。</p><p><a name="Kq7LU"></a></p><h3 id="4-2-其他情形"><a href="#4-2-其他情形" class="headerlink" title="4.2 其他情形"></a>4.2 其他情形</h3><p>部分配置修改，可能会导致</p><ol><li>重启应用程序</li><li>url改了，我们可能根据这个url要去另外一个服务那边取配置</li><li>等</li></ol><p>所以我们暴露了ApolloConfigChangeListener机制，这块的话，相当于可以交给写应用的人去判断，某些配置修改，会让他不得不重启应用，哪些配置更改了，要去别的地方联动其他一些配置，或者告知其他服务等操作。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557390264174-9c1611da-f3ed-457e-b7f5-66bd53eb46d5.png#align=left&amp;display=inline&amp;height=418&amp;name=image.png&amp;originHeight=418&amp;originWidth=444&amp;size=67052&amp;status=done&amp;width=444" alt="image.png"></p><p><a name="tVuC6"></a></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>此思路适用于其他语言，比如golang要对接配置中心的话，也可以用上面的机制来实现以下。代码不多，只是有一些注意点，大家要注意。</p><p>Http long polling的应用。<br>像WebQQ、Comment都用到长轮询技术，另外一些使用Pull模式消费的消息系统，都会使用Long Polling技术进行优化。</p><div class="post-announce">感谢您的阅读，本文由 <a href="http://blog.fedfans.com">大米小米的博客</a> 版权所有。<br>如若转载，请注明出处：大米小米的博客（<a href="http://blog.fedfans.com/page/article/严选Node对接携程Apollo配置中心/">http://blog.fedfans.com/page/article/严选Node对接携程Apollo配置中心/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/page/article/influx时序数据库/" title="Influx时序数据库"><i class="iconfont icon-prev"></i>Influx时序数据库</a></div><div class="post__prev post__prev--right"></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/问题篇/">问题篇</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/解决方案/">解决方案</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/站点维护/">站点维护</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/环境搭建/">环境搭建</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/服务器配置/">服务器配置</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/服务器/">服务器</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/日常杂记/">日常杂记</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/数据库/">数据库</a><span class="block-list-count">1</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/数据库/Influx/">Influx</a><span class="block-list-count">1</span></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/工程化/">工程化</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/后端/">后端</a><span class="block-list-count">6</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/Node/">Node</a><span class="block-list-count">2</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/Node/Koa/">Koa</a><span class="block-list-count">1</span></li></ul></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端/">前端</a><span class="block-list-count">7</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/前端/Angular/">Angular</a><span class="block-list-count">6</span></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Pandora源码分析/">Pandora源码分析</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Node/">Node</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/page/article/严选Node对接携程Apollo配置中心/" title="严选Node对接携程Apollo配置中心"><div class="item__cover"><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557386231926-fb7107ea-fbea-41fd-8e42-c334fbc68547.png" alt="严选Node对接携程Apollo配置中心"></div><div class="item__info"><h3 class="item__title">严选Node对接携程Apollo配置中心</h3><span class="item__text">2019-05-09</span></div></a></li><li class="latest-post-item"><a href="/page/article/influx时序数据库/" title="Influx时序数据库"><div class="item__cover"><img src="https://520stone-blog.oss-cn-beijing.aliyuncs.com/blog_fedfans/WX20190508-143057.png" alt="Influx时序数据库"></div><div class="item__info"><h3 class="item__title">Influx时序数据库</h3><span class="item__text">2019-05-07</span></div></a></li><li class="latest-post-item"><a href="/page/article/Angular_Ivy改变了变化检测机制,你准备好了吗/" title="Angular Ivy改变了变化检测机制，你准备好了吗?"><div class="item__cover"><img src="http://520stone-blog.oss-cn-beijing.aliyuncs.com/blog_fedfans/1_KrIqm7-40larFWM7SeU8wQ.png" alt="Angular Ivy改变了变化检测机制，你准备好了吗?"></div><div class="item__info"><h3 class="item__title">Angular Ivy改变了变化检测机制，你准备好了吗?</h3><span class="item__text">2018-10-28</span></div></a></li><li class="latest-post-item"><a href="/page/article/Angular在新版本中脏值检测机制发生了改变/" title="Angular在新版本中，脏值检测重生了《译》"><div class="item__cover"><img src="http://520stone-blog.oss-cn-beijing.aliyuncs.com/blog_fedfans/1_DEeCWAZ_UhN36xf4aY4EBg.jpeg" alt="Angular在新版本中，脏值检测重生了《译》"></div><div class="item__info"><h3 class="item__title">Angular在新版本中，脏值检测重生了《译》</h3><span class="item__text">2018-10-28</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Angular/">Angular</a></li><li class="tag-item"><a class="tag-link" href="/tags/Apollo/">Apollo</a></li><li class="tag-item"><a class="tag-link" href="/tags/Gitlab/">Gitlab</a></li><li class="tag-item"><a class="tag-link" href="/tags/Influx/">Influx</a></li><li class="tag-item"><a class="tag-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/MAVEN/">MAVEN</a></li><li class="tag-item"><a class="tag-link" href="/tags/Maven/">Maven</a></li><li class="tag-item"><a class="tag-link" href="/tags/Node/">Node</a></li><li class="tag-item"><a class="tag-link" href="/tags/NodeJS/">NodeJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/NodeJs/">NodeJs</a></li><li class="tag-item"><a class="tag-link" href="/tags/Node监控/">Node监控</a></li><li class="tag-item"><a class="tag-link" href="/tags/Pandora/">Pandora</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-item"><a class="tag-link" href="/tags/Swap/">Swap</a></li><li class="tag-item"><a class="tag-link" href="/tags/前端/">前端</a></li><li class="tag-item"><a class="tag-link" href="/tags/基建/">基建</a></li><li class="tag-item"><a class="tag-link" href="/tags/工程化/">工程化</a></li><li class="tag-item"><a class="tag-link" href="/tags/数据库/">数据库</a></li><li class="tag-item"><a class="tag-link" href="/tags/方案/">方案</a></li><li class="tag-item"><a class="tag-link" href="/tags/日志/">日志</a></li><li class="tag-item"><a class="tag-link" href="/tags/服务器/">服务器</a></li><li class="tag-item"><a class="tag-link" href="/tags/杂记/">杂记</a></li><li class="tag-item"><a class="tag-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-item"><a class="tag-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-item"><a class="tag-link" href="/tags/环境配置/">环境配置</a></li><li class="tag-item"><a class="tag-link" href="/tags/生活/">生活</a></li><li class="tag-item"><a class="tag-link" href="/tags/站点维护/">站点维护</a></li><li class="tag-item"><a class="tag-link" href="/tags/编译报错/">编译报错</a></li><li class="tag-item"><a class="tag-link" href="/tags/评论/">评论</a></li><li class="tag-item"><a class="tag-link" href="/tags/配置中心/">配置中心</a></li><li class="tag-item"><a class="tag-link" href="/tags/问题/">问题</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Hangzhou, ZheJiang Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>hzjinbing@163.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://user-images.githubusercontent.com/6525544/44786587-302e9180-abc7-11e8-9751-31499ac38a78.png" alt="logo" title="大米小米的博客"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="http://spring4all.com/" title="Spring CLoud、Spring Boot等技术栈" target="_blank">Spring For All社区</a></li><li class="list-item"><a href="https://anoyi.com/" title="ANOYI 轻量级微服务架构" target="_blank">ANOYI 轻量级微服务架构</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/stone-jin" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:hzjinbing@163.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Node","配置中心","Apollo","基建"],gitalk=new Gitalk({clientID:"63d06125b339465f0bce",clientSecret:"12a9180d9606c445e08a9e176254e2cb5a18387b",repo:"hexo-blog",owner:"stone-jin",admin:["stone-jin"],labels:tags,id:new Date(1557411198e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script>!function(t,h,e,j,s,n){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:1060458,hjsv:6},s=h.getElementsByTagName("head")[0],(n=h.createElement("script")).async=1,n.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,s.appendChild(n)}(window,document)</script></body></html>