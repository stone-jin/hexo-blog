<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Angular在新版本中，脏值检测重生了《译》 | 大米小米的博客</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="typescript, nodejs, javascript, webpack, 前端, 全栈开发"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.fedfans.com/page/article/Angular在新版本中脏值检测机制发生了改变/index.html"><link rel="icon" type="image/png" href="https://user-images.githubusercontent.com/6525544/44798832-169c4280-abe5-11e8-8b7c-618aee212586.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="大米小米的博客"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f1e4c915dd718aa486135ab51167ad12";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="大米小米的博客" alt="大米小米的博客"><img src="http://oo12ugek5.bkt.clouddn.com/images/logo-text-white.png" alt="大米小米的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://cdn-images-1.medium.com/max/800/1*DEeCWAZ_UhN36xf4aY4EBg.jpeg" alt="Angular在新版本中，脏值检测重生了《译》"></div><header class="post__info"><h1 class="post__title">Angular在新版本中，脏值检测重生了《译》</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/stone-jin">金炳</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-10-28</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Angular/">Angular</a></li><li class="mark__item"><a href="/tags/前端/">前端</a></li></ul></div></div></header><div class="post__content"><p>Angular’s $digest is gone. Long live the digest!</p><p>我用 Angular.js 工作了几年，尽管受到了广泛的批评，但我依然认为这是一个很棒的框架。我从《Builing your own Angular.js》这本书入手，并且阅读了大部分框架的源码。所以我对 Angular.js 内部工作有了扎实的了解，并且很好的掌握了框架构建的思想。现在，我试图在更新后的 Angular 中 达到相同的理解水平，并且在版本之间映射想法。我发现，与互联网声称的 Angular 相反，Angular 还是借用了其前身的很多想法。</p><p>其中一个想法就是臭名鼎鼎的<a href="https://larseidnes.com/2014/11/05/angularjs-the-bad-parts/" target="_blank" rel="noopener">循环脏值检测</a>:</p><p>这个操作在 Angular.js 中非常昂贵。改变应用程序的任何一部分将成为数百或者上千个查找更改的函数的操作。这是 Angular.js 的基本组成部分，它对可以在 Angular 中构建的 UI 的大小设置了一个硬性限制，同时保持高性能。</p><p>如果对 Angular 的脏值检测实现机制有了很好的理解，那我们同样可以将应用程序设计地非常的高效。例如：有选择性地使用$scope.$digest()而不是$scope.$apply，而不是所有地方都是用$apply，拥抱不可变对象。但事实上，需要对底下实现有一定了解才能设计高性能的应用。</p><p>因此，大多数关于 Angular 的教程都不奇怪框架中没有更多的$digest 循环。这种观点很大程度取决于我们对脏值检测的理解，但是我认为，鉴于其目的，这是一种误导性的主张。它还在那里。是的，我们没有明确的范围和观察者，也没有调用$scope.$digest，但是检查遍历组件数的更改机制，调用隐式观察者炳更新 DOM 节点。最终完全被改写，并且被大大加强了。</p><p>这篇文章探讨了 Angular.js 和 Angular 在检测这块的实现的差异。并且对于 Angular.js 的开发者会有帮助，在他们迁移到 Angular 中。</p><h2 id="变更的需要"><a href="#变更的需要" class="headerlink" title="变更的需要"></a>变更的需要</h2><p>在我们开始之前，让我们记住为什么脏值检测会在 Angular.js 中出现。每个框架解决了数据模型和 UI 之间的同步问题。这个实事过程中最大的挑战就是更改检测。这也是当今大部分知名框架在实现之间最大的区别了。我打算写一篇深入介绍变更检测机制比较的文章。如果你想要被提醒到，请关注我谢谢:)</p><p>检查变更的方法有两种主要方法–通过用户告知框架或者自动探测更改。假设我们有下面这样一个对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;name: &apos;Angular&apos;&#125;;</span><br></pre></td></tr></table></figure><p>然后我们更新了 name 字段。我们的框架如何知道它发生了变化呢？一种方法是让用户来通知框架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    let person = &#123;name: &apos;Angular&apos;&#125;;</span><br><span class="line">    this.state = person;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// explicitly notifying React about the changes</span><br><span class="line">// and specifying what is about to change</span><br><span class="line">this.setState(&#123;name: &apos;Changed&apos;&#125;);</span><br></pre></td></tr></table></figure><p>或者强迫他在属性上使用一个包装器，以方便框架添加 setter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let app = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &apos;Hello Vue!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// the setter is triggered so Vue knows what changed</span><br><span class="line">app.name = &apos;Changed&apos;;</span><br></pre></td></tr></table></figure><p>另一种方法是保存一个 name 属性的前一个值，并将其与当前值进行比较.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (previousValue !== person.name) // change detected, update DOM</span><br></pre></td></tr></table></figure><p>但什么时候应该被比较呢？我们应该在每次代码运行的时候运行检查机制。而且我们知道代码是异步时事件运行的-所谓的虚拟机 VM(反向、勾选)，我们可以在检测结束的时候进行检查操作。这就是 Angular.js 使用脏值检查的原因。所以我们可以将变更检测定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种更改检测机制，用于遍历组件树，检查每个组件的变化，并在组件属性变化发生Dom的更新</span><br></pre></td></tr></table></figure><p>如果我们使用了这个变更检测的定义，我断言主要机制并没有在新版本的 Angular 中改变。更改的知识实现变更检测的实现。</p><h2 id="Angular-js"><a href="#Angular-js" class="headerlink" title="Angular.js"></a>Angular.js</h2><p>Angular.js 使用了观察者和监听器的概念。一个观察者是一个用来返回一个被监听的对象的值的函数。通常，这些值是一个数据模型上的属性。但它并不总是数据模型上面的属性–我们也可以跟踪 scope 的状态，计算值，一个第三方组件。如果监听的值相比前面的值不一样了，angular 就会调用监听器。这个监听器通常是用来更新 UI 的。</p><p>这反应在$watch 函数的参数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch(watcher, listener);</span><br></pre></td></tr></table></figure><p>所以，如果我们有一个 person 这样的对象，这个对象里面有一个用于 html 里面展示的 name 字段，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>我们可以通过下面的方法跟踪这个属性并更新DOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$watch(() =&gt; &#123;</span><br><span class="line">return person.name</span><br><span class="line">&#125;, (value) =&gt; &#123;</span><br><span class="line">span.textContent = value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这基本上就像ng-bind这样的插值和指令。Angular.js使用指令来反射数据在DOM上的表现。最新的Angular不在那么做了。它使用了一个属性映射表来连接数据模型和DOM。现在的实现方式如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span [textContent]=&quot;person.name&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p></p><p>由于我们有许多构成树的组件，并且每一个组件都有不同的数据模型，因此我们有一个跟组件树非常相似结构的观察者层次结构。观察者使用$scope进行分组，但这并不重要。</p><p>现在，在angular.js变更检测在这个观察者树结构中走过，并且更新DOM。通常，如果你使用现有的机制$time，$http，或者通过$scope.$apply或者$scope.$digest会触发一个异步事件。</p><p>监听器会按照严格的顺序进行处罚，首先是父组件，然后是子组件。这是有道理的，但它有一些不受欢迎的含义。观察者监听器可以具有各种副作用，包括更新父组件的属性。如果已经处理了父组件，然后一个子组件更新了父组件的属性，则不会检测到更改。这就是为什么更改检测需要必须多次运行才能保持稳定-以便不再有更改。并且此类运行的数量限制是10.这个涉及限制被认为是有缺陷的，Angular不允许这么做。</p><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular没有类似于Angular.js的观察者的概念。但是跟踪数据模型属性变化的函数还是存在。这些变更函数现在是由框架编译器生成，无法访问。此外，它们现在与底层DOM紧密项链。这些函数被存储在视图View上的<a href="https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/view.ts#L140" target="_blank" rel="noopener">updateRenderer</a>的属性名称中。</p><p>它们也非常的具体–它们只跟踪数据模型中的变化，而不像Angular.js中跟踪所有的内容。每一个组件由一个观察者，它跟踪模板中使用的所有组件属性。它不是返回一个值，而是返回的是每一个被跟踪属性调用<a href="https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/text.ts#L62" target="_blank" rel="noopener">checkAndUpdateTextInline</a>的函数。这个函数会对前面的值与当前值做对比，然后当改变的时候对DOM进行更改。</p><p>例如，对于AppComponent有如下一个模板：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h1&gt;Hello &#123;&#123;model.name&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p></p><p>编译器会转换成下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function View_AppComponent_0(l) &#123;</span><br><span class="line">    // jit_viewDef2 is `viewDef` constructor</span><br><span class="line">    return jit_viewDef2(0,</span><br><span class="line">        // array of nodes generated from the template</span><br><span class="line">        // first node for `h1` element</span><br><span class="line">        // second node is textNode for `Hello &#123;&#123;model.name&#125;&#125;`</span><br><span class="line">        [</span><br><span class="line">            jit_elementDef3(...),</span><br><span class="line">            jit_textDef4(...)</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">        // updateRenderer function similar to a watcher</span><br><span class="line">        function (ck, v) &#123;</span><br><span class="line">            var co = v.component;</span><br><span class="line">            // gets current value for the component `name` property</span><br><span class="line">            var currVal_0 = co.model.name;</span><br><span class="line">            // calls CheckAndUpdateNode function passing</span><br><span class="line">            // currentView and node index (1) which uses</span><br><span class="line">            // interpolated `currVal_0` value</span><br><span class="line">            ck(v, 1, 0, currVal_0);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，即使现在以不同的方式实现了观察者，变更检测的循环还是存在。它更改了名称以更改检测周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在开发阶段，tick()会执行两次change detection cycle来确保没有新的改变被探测到。</span><br></pre></td></tr></table></figure><p>我之前提到过，在 angular.js 的变更探测会走一遍观察者树，并且更新 DOM。Angular 也做了非常相像的事情。当更改周期变动的时候，会走一遍组件树，并且调用渲染更新的函数。它是作为检查和更新视图过程的一部分完成的，我在关于 Angular 变化检测需要了解的所有内容中介绍了他。</p><p>就像 Angular.js 在教新版本中的 Angular，这个变更检测周期会被每一个异步事件触发。但是，由于 Angular 使用了 zone 来修复所有的异步时间，因此大部分事件不需要手动被触发。框架订阅了 onMicrotaskEmpty 时间，并在异步事件完成的时候收到通知。当 VMturn 中没有排队的微任务的时候就会触发此事件。但是，可以通过 view.detectChanges 或 ApplicationRef.tick 方法来手动触发更改检测。</p><p>Angular 强制使用了所谓的从上到下的单向数据流模型。在处理父组件被处理完毕后，不允许层次结构较低的结构更新父组件的属性。如果组件在 DoCheck 挂钩中更新了父组件模型属性，则可以正常工作，因为在检测到属性更改之前会调用此声明周期挂钩。但是，如果以其他方式去更新父组件的属性，例如，在处理更改后调用的 AfterViewChecked 挂钩是，则会在开发模式下获得以下报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression has changed after it was checked</span><br></pre></td></tr></table></figure><p>你可以在文章《<a href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" target="_blank" rel="noopener">您需要了解有关 <code>Expression Changed After It Has Been Checked Error</code>这个错误的所有信息</a>》了解更多的信息。</p><p>在生产环境中，这个错误将不会出现，只有当 Angular 执行下一个更改周期的时候才会探测到这个改动。</p><h2 id="使用生命周期钩子来跟踪变化"><a href="#使用生命周期钩子来跟踪变化" class="headerlink" title="使用生命周期钩子来跟踪变化"></a>使用生命周期钩子来跟踪变化</h2><p>在 Angular.js 中，每一个组件定义了一系列的跟踪者来跟踪下面这些信息:</p><ul><li>父组件的数据绑定</li><li>自己组件的属性</li><li>计算的值 ( computed value)</li><li>Angular 生态圈以外的第三方组件</li></ul><p>以下是如何在 Angular 中实现这些功能的。要跟踪父组件绑定属性，我们会使用 OnChange 生命周期的钩子。</p><p>我们可以使用 DoCheck 生命周期来跟踪自己组件属性和计算属性。因为这个周期会在 Angular 流程属性发生更改之前触发，因此我们可以执行任何我们操作以反应到界面上。</p><p>我们可以使用 OnInit 来监听 Angular 生态圈以外的变化，并且手动探测变化。</p><p>例如，我们有一个展示当前时间的组件。这个时间由 Time Servicce 提供。这是 Angular.js 中的实现方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function link(scope, element) &#123;</span><br><span class="line">    scope.$watch(() =&gt; &#123;</span><br><span class="line">        return Time.getCurrentTime();</span><br><span class="line">    &#125;, (value) =&gt; &#123;</span><br><span class="line">        $scope.time = value;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们在 Angular 中的实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class TimeComponent &#123;</span><br><span class="line">    ngDoCheck()</span><br><span class="line">    &#123;</span><br><span class="line">        this.time = Time.getCurrentTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，如果我们有一个第三方的滑块的组件，没有集成到 Angular 的生态系统中，单我们需要展示当前的页面，我们只需要简单的包装秤一个 Angular 组件，来跟踪滑块的更改时间，并且手动触发更改来反映到 UI 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function link(scope, element) &#123;</span><br><span class="line">    slider.on(&apos;changed&apos;, (slide) =&gt; &#123;</span><br><span class="line">        scope.slide = slide;</span><br><span class="line"></span><br><span class="line">        // detect changes on the current component</span><br><span class="line">        $scope.$digest();</span><br><span class="line"></span><br><span class="line">        // or run change detection for the all app</span><br><span class="line">        $rootScope.$digest();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular 的想法也是一样的。以下是它的实现方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SliderComponent &#123;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        slider.on(&apos;changed&apos;, (slide) =&gt; &#123;</span><br><span class="line">            this.slide = slide</span><br><span class="line"></span><br><span class="line">            // detect changes on the current component</span><br><span class="line">            // this.cd is an injected ChangeDetector instance</span><br><span class="line">            this.cd.detectChanges();</span><br><span class="line"></span><br><span class="line">            // or run change detection for the all app</span><br><span class="line">            // this.appRef is an ApplicationRef instance</span><br><span class="line">            this.appRef.tick();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是全部的内容了!</p><div class="post-announce">感谢您的阅读，本文由 <a href="http://blog.fedfans.com">大米小米的博客</a> 版权所有。<br>如若转载，请注明出处：大米小米的博客（<a href="http://blog.fedfans.com/page/article/Angular在新版本中脏值检测机制发生了改变/">http://blog.fedfans.com/page/article/Angular在新版本中脏值检测机制发生了改变/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/page/article/五篇让你成为Angular变化检测专家/" title="5篇让你成为Angular变化检测专家《译》"><i class="iconfont icon-prev"></i>5篇让你成为Angular变化检测专家《译》</a></div><div class="post__prev post__prev--right"><a href="/page/article/Angular Ivy改变了变化检测机制，你准备好了吗?/" title="Angular Ivy改变了变化检测机制，你准备好了吗?">Angular Ivy改变了变化检测机制，你准备好了吗?<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/问题篇/">问题篇</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/解决方案/">解决方案</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/站点维护/">站点维护</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/环境搭建/">环境搭建</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/服务器配置/">服务器配置</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/服务器/">服务器</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/日常杂记/">日常杂记</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/工程化/">工程化</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/后端/">后端</a><span class="block-list-count">6</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/Node/">Node</a><span class="block-list-count">2</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/Node/Koa/">Koa</a><span class="block-list-count">1</span></li></ul></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端/">前端</a><span class="block-list-count">7</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/前端/Angular/">Angular</a><span class="block-list-count">6</span></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Pandora源码分析/">Pandora源码分析</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/page/article/Angular Ivy改变了变化检测机制，你准备好了吗?/" title="Angular Ivy改变了变化检测机制，你准备好了吗?"><div class="item__cover"><img src="https://cdn-images-1.medium.com/max/2000/1*KrIqm7-40larFWM7SeU8wQ.png" alt="Angular Ivy改变了变化检测机制，你准备好了吗?"></div><div class="item__info"><h3 class="item__title">Angular Ivy改变了变化检测机制，你准备好了吗?</h3><span class="item__text">2018-10-28</span></div></a></li><li class="latest-post-item"><a href="/page/article/Angular在新版本中脏值检测机制发生了改变/" title="Angular在新版本中，脏值检测重生了《译》"><div class="item__cover"><img src="https://cdn-images-1.medium.com/max/800/1*DEeCWAZ_UhN36xf4aY4EBg.jpeg" alt="Angular在新版本中，脏值检测重生了《译》"></div><div class="item__info"><h3 class="item__title">Angular在新版本中，脏值检测重生了《译》</h3><span class="item__text">2018-10-28</span></div></a></li><li class="latest-post-item"><a href="/page/article/五篇让你成为Angular变化检测专家/" title="5篇让你成为Angular变化检测专家《译》"><div class="item__cover"><img src="https://cdn-images-1.medium.com/max/1600/1*Ay1gyH93CjHtaygkh5Od_w.jpeg" alt="5篇让你成为Angular变化检测专家《译》"></div><div class="item__info"><h3 class="item__title">5篇让你成为Angular变化检测专家《译》</h3><span class="item__text">2018-10-28</span></div></a></li><li class="latest-post-item"><a href="/page/article/Angular_OnPush组件中ngDoCheck和AsyncPipe的区别/" title="Angular OnPush组件中ngDoCheck和AsyncPipe的区别"><div class="item__cover"><img src="https://520stone-blog.oss-cn-beijing.aliyuncs.com/blog_fedfans/%E4%BF%AE%E7%BA%BF%E8%B7%AF.jpg" alt="Angular OnPush组件中ngDoCheck和AsyncPipe的区别"></div><div class="item__info"><h3 class="item__title">Angular OnPush组件中ngDoCheck和AsyncPipe的区别</h3><span class="item__text">2018-10-28</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Angular/">Angular</a></li><li class="tag-item"><a class="tag-link" href="/tags/Gitlab/">Gitlab</a></li><li class="tag-item"><a class="tag-link" href="/tags/JAVA/">JAVA</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/MAVEN/">MAVEN</a></li><li class="tag-item"><a class="tag-link" href="/tags/Maven/">Maven</a></li><li class="tag-item"><a class="tag-link" href="/tags/NodeJS/">NodeJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/NodeJs/">NodeJs</a></li><li class="tag-item"><a class="tag-link" href="/tags/Node监控/">Node监控</a></li><li class="tag-item"><a class="tag-link" href="/tags/Pandora/">Pandora</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-item"><a class="tag-link" href="/tags/Swap/">Swap</a></li><li class="tag-item"><a class="tag-link" href="/tags/前端/">前端</a></li><li class="tag-item"><a class="tag-link" href="/tags/工程化/">工程化</a></li><li class="tag-item"><a class="tag-link" href="/tags/方案/">方案</a></li><li class="tag-item"><a class="tag-link" href="/tags/日志/">日志</a></li><li class="tag-item"><a class="tag-link" href="/tags/服务器/">服务器</a></li><li class="tag-item"><a class="tag-link" href="/tags/杂记/">杂记</a></li><li class="tag-item"><a class="tag-link" href="/tags/源码阅读/">源码阅读</a></li><li class="tag-item"><a class="tag-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-item"><a class="tag-link" href="/tags/环境配置/">环境配置</a></li><li class="tag-item"><a class="tag-link" href="/tags/生活/">生活</a></li><li class="tag-item"><a class="tag-link" href="/tags/站点维护/">站点维护</a></li><li class="tag-item"><a class="tag-link" href="/tags/编译报错/">编译报错</a></li><li class="tag-item"><a class="tag-link" href="/tags/评论/">评论</a></li><li class="tag-item"><a class="tag-link" href="/tags/问题/">问题</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Hangzhou, ZheJiang Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>hzjinbing@163.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://user-images.githubusercontent.com/6525544/44786587-302e9180-abc7-11e8-9751-31499ac38a78.png" alt="logo" title="大米小米的博客"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="http://spring4all.com/" title="Spring CLoud、Spring Boot等技术栈" target="_blank">Spring For All社区</a></li><li class="list-item"><a href="https://anoyi.com/" title="ANOYI 轻量级微服务架构" target="_blank">ANOYI 轻量级微服务架构</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/stone-jin" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:hzjinbing@163.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Angular","前端"],gitalk=new Gitalk({clientID:"63d06125b339465f0bce",clientSecret:"12a9180d9606c445e08a9e176254e2cb5a18387b",repo:"hexo-blog",owner:"stone-jin",admin:["stone-jin"],labels:tags,id:new Date(15407145e5).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script>!function(t,h,e,j,s,n){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:1060458,hjsv:6},s=h.getElementsByTagName("head")[0],(n=h.createElement("script")).async=1,n.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,s.appendChild(n)}(window,document)</script></body></html>