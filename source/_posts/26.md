---
title: （三）Spring Boot中使用Spring Security进行安全控制之用户数据数据库化-高级篇
cover: https://img.zcool.cn/community/011e475b86a540a80120245c336724.jpg@1280w_1l_2o_100sh.jpg
subtitle: Spring Boot中使用Spring Security进行安全控制之前后端分离模式-扩展篇
date: 2018-04-29 00:26:45
author: 
  nick: 金炳
  link: https://www.github.com/stone-jin
categories:
- Spring Cloud
tags:
- JAVA
- Spring Cloud
---

## 一、前言
前面我们介绍了，如何使用SpringBoot结合Spring Security进行代码的安全控制，同时我们定制化开发了我们的登录页面和登入之后的用户获取，同时退出功能。

## 二、介绍
本章我们将要介绍如何将用户数据变成数据库，同时Spring Security里面的用户本身是有个类的，带大家一块来了解和认识这个类。WebSecurityConfigurerAdapter是Spring Security提供给我们的adapter，上一章节，我们overwrite了函数configure方法，本篇也跟这个类有关，我们此次要overwrite这个方法：protected void configure(AuthenticationManagerBuilder auth) throws Exception，同时我们要创建一个Bean。

```java
@Bean
UserDetailsService customUserService() {
    return new UserDetailsServiceImpl();
}

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(customUserService());
}
```

以上代码里面我们看到我们要调用auth.userDetailsService来进行传入一个service。

然后这个service，我们也需要继承Spring security里面的一个UserDetailsService的接口类，

```java
@Service
@Slf4j
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        log.info("[loadUserByUsername] s: {}", s);
        UserPO userPO = userMapper.getUserByName(s);
        if(Objects.equals(userPO, null)){
            throw new UsernameNotFoundException("");
        }else{
            log.info("userPO={}", userPO);
            return userPO;
        }
    }
}
```

然后我们就需要去定义跟数据库相关的VO了，所以我们此处使用SpringBoot + mybatis + mysql来处理，引入pom包：

```text
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
   <groupId>org.mybatis.spring.boot</groupId>
   <artifactId>mybatis-spring-boot-starter</artifactId>
   <version>1.3.1</version>
</dependency>
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

引入完pom包后，我们重新reimport一下这些包。

然后我们跟平常我们操作数据库的方式差不多，但是定义entity的时候，可以继承下Spring Security里面的UserDetails，大概我们的数据库字段有哪些就清楚明白了。

此处我们看到Spring Security里面主要有用户的名字，用户的密码，是否是enabled，是否过期，是否锁定，还有权限。

针对业务系统里面常用的用户，角色，权限的概念，本文不详细展开，基本使用RBAC的方案。

自此，理论知识基本完毕了。

三、截图和git代码
然后我们数据库里面的截图：

![](https://520stone-blog.oss-cn-beijing.aliyuncs.com/upload/2018-04-29T15:29:32Z/fe9c3863-c075-4568-8150-a912bdfee1e2.png)

本文涉及到的代码放到了：https://github.com/stone-jin/spring-boot-security3

四、总结
自此从SpringBoot结合Spring Security方案的文章，还剩下如何结合当前互联网的前后端分离模式，SPA的前端，然后后端提供ajax，然后最终打包的时候放到后端里面，因为Spring Security里面使用了csrf策略，所以我们前端代码里面肯定是要处理的。

下面一篇文章，我们会进行这部分的讲解，同时本文的代码，也会调试完毕后放出来。本文作者还在酝酿中