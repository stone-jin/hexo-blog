<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大米小米的博客</title>
  
  <subtitle>大米小米的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fedfans.com/"/>
  <updated>2018-10-28T08:04:53.787Z</updated>
  <id>http://blog.fedfans.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5篇让你成为Angular变化检测专家《译》</title>
    <link href="http://blog.fedfans.com//page/article/%E4%BA%94%E7%AF%87%E8%AE%A9%E4%BD%A0%E6%88%90%E4%B8%BAAngular%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E4%B8%93%E5%AE%B6/"/>
    <id>http://blog.fedfans.com//page/article/五篇让你成为Angular变化检测专家/</id>
    <published>2018-10-28T07:00:00.000Z</published>
    <updated>2018-10-28T08:04:53.787Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的 8 个月中，我花了大部分空闲时间对 Angular 进行逆向工程。最让我着迷的主题是变化检测。我认为它是框架中最重要的部分，因为它负责”可见”工作，如 DOM 更新，输入绑定和查询列表更新。我的探索产生了一系列深入的文章，主要突出了变量检测机制的主要思想，并深入探讨了实现细节。在这篇文章中，我将它们放在一起，并简要描述了每个内容。阅读完之后，你会获取变化检测启发。</p><h2 id="理解变化检测"><a href="#理解变化检测" class="headerlink" title="理解变化检测"></a>理解变化检测</h2><p>以下五篇深入文章，将显著提升您对 Angular 中变更检测这块的了解。每一篇文章都是基于前一篇文章中解释的信息，因此我建议你按顺序阅读他们。</p><h3 id="Angular-在新版本中，脏值检测发生了新的改变"><a href="#Angular-在新版本中，脏值检测发生了新的改变" class="headerlink" title="Angular 在新版本中，脏值检测发生了新的改变"></a><a href="https://blog.angularindepth.com/angulars-digest-is-reborn-in-the-newer-version-of-angular-718a961ebd3e" target="_blank" rel="noopener">Angular 在新版本中，脏值检测发生了新的改变</a></h3><p>这篇文章对 AngularJS 的脏值检测机制和 Angular 中的更改变更机制做了对比。它解释了对他们的需求，并展示了如何使用相同的脏检查概念构建它们。然后它提供了一些示例，演示了 Angular 中的生命周期钩子如何用作 AngularJS 中$wattch 的等效机制。它还显示了 Angular 与 AngularJS 的不同之处，因为它现在强制执行所谓的从上到下的所谓单向数据流。本文解释了实施背后的原因，它对架构的好处和限制。本文对于希望迁移到 Angular，正在使用 AngularJS 的开发者很有帮助。</p><h3 id="你是否依然仍未-Angular-中的变量检测需要-NgZone-zone-js"><a href="#你是否依然仍未-Angular-中的变量检测需要-NgZone-zone-js" class="headerlink" title="你是否依然仍未 Angular 中的变量检测需要 NgZone(zone.js)"></a><a href="https://blog.angularindepth.com/do-you-still-think-that-ngzone-zone-js-is-required-for-change-detection-in-angular-16f7a575afef" target="_blank" rel="noopener">你是否依然仍未 Angular 中的变量检测需要 NgZone(zone.js)</a></h3><p>这篇文章描述了如何在 zone.js 库之上实现了 NgZone，并解释了 NgZone 在框架中扮演的角色。与普遍看法相反，它并不是变化检测过程的一部分，而是用于触发它。本文首先演示了 Angular 如何在没有 NgZone 和 zone.js 的情况下检测更改，并执行渲染。然后它继续展示 NgZone 带来了什么价值以及它是如何实现的。本文的大部分内容致力于解释常用的公共 API，如 isStable，onUnstable 和 onMicrotaskEmpty.本文最后解释了使用像 GoogleAPI 这样的第三方库时未检测到的变化的常见缺陷。</p><h3 id="你需要知道的-Angular-中的更改检测的所有信息"><a href="#你需要知道的-Angular-中的更改检测的所有信息" class="headerlink" title="你需要知道的 Angular 中的更改检测的所有信息"></a><a href="https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f" target="_blank" rel="noopener">你需要知道的 Angular 中的更改检测的所有信息</a></h3><p>如果你想要牢固掌握变化检测机制，那么这篇文章是必读的。它提供了如何使用相关连接实现引擎的高级概述，以便进一步的探索。这篇文章先介绍了名为 View 的内部组件，并且介绍了变量检测是如何在 View 上面进行工作的。然后，它按执行顺序显示在更改检测期间执行的所有操作的列表。这些操作包括更新视图状态、渲染、处理输入绑定和调用生命周期钩子。最后，他解释了 ChangeDetectorRef 公共 API，如 detach，detectChanges 和 markForCheck，并提供了这些方法的简单示例。</p><h3 id="Angular-中-DOM-更新的机制"><a href="#Angular-中-DOM-更新的机制" class="headerlink" title="Angular 中 DOM 更新的机制"></a><a href="https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d" target="_blank" rel="noopener">Angular 中 DOM 更新的机制</a></h3><p>这篇文章深入探讨了将应用程序模型与 DOM,a.k.a 单向数据绑定或 DOM 渲染呈现工程的实现细节。此操作在更改变更过程中占据了中心的位置，因为她正是在 DOM 中呈现组件更改的原因。本文首先披露了有关 View 概念的其他详细的信息，特别是 View Factory 和几种基本类型的 View 节点。然后，它显示了更改检测机制如何通过插值或输入绑定为这些节点执行 DOM 更新设置。</p><h3 id="Angular-中的属性绑定更新机制"><a href="#Angular-中的属性绑定更新机制" class="headerlink" title="Angular 中的属性绑定更新机制"></a><a href="https://blog.angularindepth.com/the-mechanics-of-property-bindings-update-in-angular-39c0812bc4ce" target="_blank" rel="noopener">Angular 中的属性绑定更新机制</a></h3><p>与前一篇关于 DOM 更新的文章类似，本文升入探讨了更新子组件和指令的输入绑定过程的实现机制。它介绍了绑定定义的概念和其在变更检测过程中的作用。然后，它继续演示了编译器在处理属性绑定的模板语法时如何生成这些绑定定义。最后，它概述了再 View 节点上运行更改检测和指令的输入属性上分布过程。</p><h2 id="避免常见混淆"><a href="#避免常见混淆" class="headerlink" title="避免常见混淆"></a>避免常见混淆</h2><p>这里是一份附加的有价值的文章列表，主要是为了清除那些我常常在 StackOverflow 上面看到的关于变更检测方面的一些混淆。</p><h3 id="认为变更检测是深度优先的人，和广度优先的人通常都是对的"><a href="#认为变更检测是深度优先的人，和广度优先的人通常都是对的" class="headerlink" title="认为变更检测是深度优先的人，和广度优先的人通常都是对的"></a><a href="https://blog.angularindepth.com/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-8b6bf24a63e6" target="_blank" rel="noopener">认为变更检测是深度优先的人，和广度优先的人通常都是对的</a></h3><p>这篇文章回答了一个有趣的问题，Angular 是否首先检查当前组件（广度优先顺序）或其子节点（深度优先）的星弟节点。它显示了 Angular 在实际开始检查他们之间如何触发兄弟组件上的生命周期钩子，并解释了这种行为如何导致您得到错误的答案。</p><h3 id="你真的知道-Angular-中单向数据流的含义嘛"><a href="#你真的知道-Angular-中单向数据流的含义嘛" class="headerlink" title="你真的知道 Angular 中单向数据流的含义嘛?"></a><a href="https://blog.angularindepth.com/do-you-really-know-what-unidirectional-data-flow-means-in-angular-a6f55cefdc63" target="_blank" rel="noopener">你真的知道 Angular 中单向数据流的含义嘛?</a></h3><p>这篇文章介绍了单向数据绑定和单向数据流的区别。他演示了 Angular 与 AngularJS 之间更新输入绑定的过程的不同之处，以及这种差异在何处非常的重要。</p><h3 id="您需要了解有关-Expression-Changed-After-It-Has-Been-Checked-Error这个错误的所有信息"><a href="#您需要了解有关-Expression-Changed-After-It-Has-Been-Checked-Error这个错误的所有信息" class="headerlink" title="您需要了解有关 Expression Changed After It Has Been Checked Error这个错误的所有信息"></a><a href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" target="_blank" rel="noopener">您需要了解有关 <code>Expression Changed After It Has Been Checked Error</code>这个错误的所有信息</a></h3><p>这篇文章解释了 Angular 社区中频繁并经常被误解的错误背后的推理和机制。虽然一些开发人员将其视为一种错误，单实际上这是一个设计决策，通过将变更检测运行限制为单次运行来提高性能，而不是 AngularJS 中的大量运行($digest 运行).本文介绍了抛出错误有助于防止数据模型和 UI 之间的不一致问题。从而不会向用户展示的数据是错误的或者旧的数据。这篇文章主要由两部分构成，首先探讨了错误的原因，第二部分提出了可能的修复办法。他还解释了为什么在生产环境中为什么不会抛出这个问题。</p><h3 id="如果你认为ngDoCheck意味着你的组件正在被检查"><a href="#如果你认为ngDoCheck意味着你的组件正在被检查" class="headerlink" title="如果你认为ngDoCheck意味着你的组件正在被检查"></a><a href="https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5" target="_blank" rel="noopener">如果你认为<code>ngDoCheck</code>意味着你的组件正在被检查</a></h3><p>这篇文章为 OnPush 策略的组件触发 ngDoCheck 生命周期钩子的问题提供了详细的解答，即使这些组件的输入参数并没有发生改变。它解释了通常意外的事实，即在检查父组件时为子组件触发挂钩，并显示该机制如何触发 ngDoCheck，即使看起来没有理由这么做。本文第二部分通过演示一些例子来回答为什么我们需要 ngDoCheck 的问题。</p><h3 id="Angular-中构造函数和-ngOnInit-之间的本质区别"><a href="#Angular-中构造函数和-ngOnInit-之间的本质区别" class="headerlink" title="Angular 中构造函数和 ngOnInit 之间的本质区别"></a><a href="https://blog.angularindepth.com/the-essential-difference-between-constructor-and-ngoninit-in-angular-c9930c209a42" target="_blank" rel="noopener">Angular 中构造函数和 ngOnInit 之间的本质区别</a></h3><p>这篇文章中提供了一个完美的回答了最最流行的有关于 stackoverflow 上面的一个 Angular 问题，这个问题被 100K 查看，就是关于构造函数和 ngOnInit 之间的区别。本文给出了一个全面的比较，突出了使用的差异，并且还涉及了组件初始化的过程。</p><h2 id="Angular-Air-插曲"><a href="#Angular-Air-插曲" class="headerlink" title="Angular Air 插曲"></a>Angular Air 插曲</h2><p>我还强烈建议大家观看<a href="https://www.youtube.com/watch?v=WizqXZjztss&amp;feature=youtu.be" target="_blank" rel="noopener">Angular Air episode</a>，在那边我谈论了视图层的内部表示和更改检测渲染的部分。我还阐述了一些与区域相关的常见误解，以及使用<a href="https://angular.io/api/core/ChangeDetectorRef" target="_blank" rel="noopener">ChangeDetectorRef</a>手动控制变化检测。</p><h2 id="有关于-Angular-内部实现原理独一无二的书"><a href="#有关于-Angular-内部实现原理独一无二的书" class="headerlink" title="有关于 Angular 内部实现原理独一无二的书"></a>有关于 Angular 内部实现原理独一无二的书</h2><p>我已经开始写一本 Angular 内部架构的综合性书籍。它将取名为<inside angular="">。这本书深入介绍框架的架构，并且详细介绍了编译器、视图、DI、变更检测机制的工作原理。我还计划在加入一些关于性能优化和调试的例子实际例子。这本书大概 150-200 页左右，并将有大量的图表以方便大家的理解材料。如果你感兴趣，请查看您是否会购买一本关于 Angular internals 的书籍？该文章提供了一些书记的信息，并且包含了一个订阅列表，您可以用它来告诉我您是否有兴趣购买该书。</inside></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在过去的 8 个月中，我花了大部分空闲时间对 Angular 进行逆向工程。最让我着迷的主题是变化检测。我认为它是框架中最重要的部分，因为它负责”可见”工作，如 DOM 更新，输入绑定和查询列表更新。我的探索产生了一系列深入的文章，主要突出了变量检测机制的主要思想，并深入探
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular OnPush组件中ngDoCheck和AsyncPipe的区别</title>
    <link href="http://blog.fedfans.com//page/article/Angular_OnPush%E7%BB%84%E4%BB%B6%E4%B8%ADngDoCheck%E5%92%8CAsyncPipe%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.fedfans.com//page/article/Angular_OnPush组件中ngDoCheck和AsyncPipe的区别/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2018-10-28T08:05:34.078Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要深入介绍，在 Angular 中，关于如何手动控制变动改动。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg" alt=""></p><p>此文主要是为了答复 Shai 在推特上的提问。他咨询了关于用 ngDoCheck 来手动比较 values 的方法来替换使用推荐的 asyn 管道的方法 是否依然可行。这是一个比较好的提问，因为这需要对于 angular 给我们提供的 hook 有更多的了解，比如:检测机制，pipes，生命周期的 hook。接下来让我来说一下吧。</p><p>首先，我先演示如何手动触发 change detetion。这些技术使你可以更好的在 Angular 在输入绑定和异步值检查时做更好的比较。接下来让我与您分享对于这些解决方法在性能方面影响的一些看法吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是一个在ag-Grid方面的开发拥护者。如果你对了解数据网格或者正在寻找Angular在数据网格这块的解决方案，可以阅读[Get started with Angular grid in 5 minutes](https://medium.com/ag-grid/get-started-with-angular-grid-in-5-minutes-83bbb14fac93)或者向我提一些问题。</span><br></pre></td></tr></table></figure><p>接下来让我们开始吧。</p><h2 id="OnPush-Components"><a href="#OnPush-Components" class="headerlink" title="OnPush Components"></a>OnPush Components</h2><p>在 Angular 中，我们有一个非常常见的优化技能，就是去添加 ChangeDetectionStrategy.OnPush 到 component 的 decorator 的 metadata 中。假设我们有两个简单层次的组件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;b-comp&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这样的配置，Angular 每次都会对 A 和 B 组件始终运行更改检测。如果现在我们给 B 组件添加了 OnPush 的策略的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>只有在其输入绑定发生更改的时，Angular 才会对 B 组件运行更改检测。上面由于此时它并没有进行输入绑定，所以在启动期间，只会对 B 组件进行一次更改检测。</p><h2 id="手动触发变更检测"><a href="#手动触发变更检测" class="headerlink" title="手动触发变更检测"></a>手动触发变更检测</h2><p>那么是否有一种给 B 组件强制触发更改检测的方法呢？答案，当然是的，我们可以通过注入 changeDetectorRef，并且使用 markForCheck 方法来告知 Angular 当前组件需要进行更改检测。因为根据生命周期，NgDoCheck hook 会被触发，所以我们可以用下面的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        this.cd.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，当 Angular 检查父组件 A 的时候，会对 B 进行变更检测。接下来让我们看看如何使用吧。</p><h2 id="输入绑定"><a href="#输入绑定" class="headerlink" title="输入绑定"></a>输入绑定</h2><p>我们说过，Angular 只会在绑定发生变化的时候，对 OnPush 的组件进行变更检测。所有让我们看一个输入绑定的例子。假设我们有一个通过从父组件传递下来的输入对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件 A 中，我们定义了一个对象，并且实现了 changeName 的方法，这个方法需要在单击按钮时，更新这个对象的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;button (click)=&quot;changeName()&quot;&gt;Trigger change detection&lt;/button&gt;</span><br><span class="line">        &lt;b-comp [user]=&quot;user&quot;&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;</span><br><span class="line">    user = &#123;name: &apos;A&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.user.name = &apos;B&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果现在我们运行这个例子，则再第一次变更检测之后，我们将会看到用户的 name 打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User name: A</span><br></pre></td></tr></table></figure><p>但是当我们点击了按钮，并且在回调函数中改变了变量的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeName() &#123;</span><br><span class="line">    this.user.name = &apos;B&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名字并不会在屏幕上更新。我们知道这是因为 Angular 对 Input 的参数只进行浅比较，此处 user 变量的引用没有发生变化。那么我们怎么来解决这个问题呢?</p><p>好吧，我们可以在检测到差异时，手动检查名称并触发变化检测:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">    previousName = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        if (this.previousName !== this.user.name) &#123;</span><br><span class="line">            this.previousName = this.user.name;</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行了这个代码，你将在屏幕上看到更新的名字。</p><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p>现在，让我们的例子更复杂一些。我们将介绍一种基于 RxJs 的服务，它可以异步发出一个更新。它有点类似于 NgRx 体系结构。我将使用 BehaviorSubject 作为值的来源，因为我需要以初始值启动流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;button (click)=&quot;changeName()&quot;&gt;Trigger change detection&lt;/button&gt;</span><br><span class="line">        &lt;b-comp [user]=&quot;user&quot;&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;</span><br><span class="line">    stream = new BehaviorSubject(&#123;name: &apos;A&apos;&#125;);</span><br><span class="line">    user = this.stream.asObservable();</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.stream.next(&#123;name: &apos;B&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们在子组件中收到此用户变量流。我们需要订阅流并检查值是否更新。这样做的常用方法是使用异步管道。</p><h2 id="异步管道"><a href="#异步管道" class="headerlink" title="异步管道"></a>异步管道</h2><p>所以这里是子组件 B 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;(user | async).name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackblitz.com/edit/angular-q8n3qj?file=src%2Fapp%2Fa.component.ts" target="_blank" rel="noopener">查看例子</a>。但是有另一种不使用异步管道的方法吗？</p><h2 id="手动检查和更改检测"><a href="#手动检查和更改检测" class="headerlink" title="手动检查和更改检测"></a>手动检查和更改检测</h2><p>是的，我们可以手动检查值并在需要的时候来触发更改检测。正如我们开头的例子一样，我们可以使用 NgDoCheck 的生命周期的钩子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input(&apos;user&apos;) user$;</span><br><span class="line">    user;</span><br><span class="line">    previousName = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user$.subscribe((user) =&gt; &#123;</span><br><span class="line">            this.user = user;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        if (this.previousName !== this.user.name) &#123;</span><br><span class="line">            this.previousName = this.user.name;</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以体验下: <a href="https://stackblitz.com/edit/angular-4xuug1?file=src%2Fapp%2Fb.component.ts" target="_blank" rel="noopener">例子</a></p><p>理想情况，我们希望从 NgDoCheck 移动我们的比较和更新逻辑并将其放到订阅回调中，因为那时新值将可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input(&apos;user&apos;) user$;</span><br><span class="line">    user = &#123;name: null&#125;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user$.subscribe((user) =&gt; &#123;</span><br><span class="line">            if (this.user.name !== user.name) &#123;</span><br><span class="line">                this.cd.markForCheck();</span><br><span class="line">                this.user = user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackblitz.com/edit/angular-lvtfve?file=src%2Fapp%2Fb.component.ts" target="_blank" rel="noopener">例子</a></p><p>有趣的是，这正是异步管道在幕后做的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Pipe(&#123;name: &apos;async&apos;, pure: false&#125;)</span><br><span class="line">export class AsyncPipe implements OnDestroy, PipeTransform &#123;</span><br><span class="line">  constructor(private _ref: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  transform(obj: ...): any &#123;</span><br><span class="line">    ...</span><br><span class="line">    this._subscribe(obj);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (this._latestValue === this._latestReturnedValue) &#123;</span><br><span class="line">      return this._latestReturnedValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._latestReturnedValue = this._latestValue;</span><br><span class="line">    return WrappedValue.wrap(this._latestValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private _subscribe(obj): void &#123;</span><br><span class="line">    ...</span><br><span class="line">    this._strategy.createSubscription(</span><br><span class="line">        obj, (value: Object) =&gt; this._updateLatestValue(obj, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private _updateLatestValue(async: any, value: Object): void &#123;</span><br><span class="line">    if (async === this._obj) &#123;</span><br><span class="line">      this._latestValue = value;</span><br><span class="line">      this._ref.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那么哪一种解决方案更快"><a href="#那么哪一种解决方案更快" class="headerlink" title="那么哪一种解决方案更快?"></a>那么哪一种解决方案更快?</h2><p>现在我们知道了如何使用手动更改检测而不是异步管道，让我们回答我们最开始的问题。谁更快？</p><p>嗯，这取决于你如何比较他们，但在其他条件相同的情况下，手动方法会更快。我不认为这种区别是有形的。以下是为什么手动方法可以更快的几个例子。</p><p>就内存而言，您不需要创建 Pipe 类的实例。就编译而言，编译器不必花时间解析管道特定语法并生成管道特定输出。在运行时方面，您可以使用异步管道为组件上的每一个更改检测运行保存几个函数调用。这是为管道代码生成的 updateRenderer 函数的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function (_ck, _v) &#123;</span><br><span class="line">    var _co = _v.component;</span><br><span class="line">    var currVal_0 = jit_unwrapValue_7(_v, 3, 0, asyncpipe.transform(_co.user)).name;</span><br><span class="line">    _ck(_v, 3, 0, currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所见，异步管道的代码调用管道实例上的 transorm 方法以获取新值。管道将返回从订阅中收到的最新值。</p><p>将其与手动方法生成的普通方法进行比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function(_ck,_v) &#123;</span><br><span class="line">    var _co = _v.component;</span><br><span class="line">    var currVal_0 = _co.user.name;</span><br><span class="line">    _ck(_v,3,0,currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是 Angular 在检查 B 组件时执行的功能。</p><h2 id="一些更有趣的事情"><a href="#一些更有趣的事情" class="headerlink" title="一些更有趣的事情"></a>一些更有趣的事情</h2><p>与执行浅比较的输入绑定不同，异步管道的实现变更不执行比较（感谢 Olena Horal 特别提到的）。它将每个新的 emission 作为更新处理，即使它与之前的 emission 相同。这是发成相同对象父组件 A 的实现。尽管如此，Angular 仍然运行 B 组件的变化检测:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class AComponent &#123;</span><br><span class="line">    o = &#123;name: &apos;A&apos;&#125;;</span><br><span class="line">    user = new BehaviorSubject(this.o);</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.user.next(this.o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着每次发出新值时，都会标记具有异步管道的组件以进行检测。并且 Angular 将在下次运行变更检测时检查组件，即使该值未更改。</p><p>这有什么关系？好吧，在我们例子中，我们只对用户的属性名称该兴趣，因为我们在模板中使用它。我们并不关心整个对象以及对对象应用可能会改变的事实。如果名称相同，我们不需要重新渲染组件。但你无法用异步管道来避免这种情况。</p><p>NgDoCheck 本身并非没有问题:)由于只有在检查了父组件时才会触发钩子，如果其中一个父组件使用了 OnPush 策略并且在更改变更期间未做检查，则不会触发该钩子。因此，当您通过服务收到新值时，不能依赖它来触发更改检测。在这种情况下，我在订阅回调中使用 markForCheck 显示的解决方案是可行的方法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基本上，手动比较可以让您更好的控制检查。您可以定义何时检查组件。这与很多其他工具相同-手动控制为您提供了更大的灵活性，但您必须知道自己在做什么。为了获得这些知识，我鼓励您投入时间和精力来学习和阅读资源。</p><p>如果您担心调用 NgDoCheck 生命周期的评率，或者它会比管道变更更换更频繁的调用。首先请不要做。首先我们展示了上面的解决方案，您不使用异步流的手动方法中的钩子。其次，只有在检查父组件时才会调用钩子。如果未选中父组件，则不会调用该挂钩。关于管道，由于流中的浅层检查和更改引用，您将使用管道的转换方法火的相同数量的调用或甚至更多。</p><h2 id="想要了解更多有关-Angular-中变更检查的更多信息？"><a href="#想要了解更多有关-Angular-中变更检查的更多信息？" class="headerlink" title="想要了解更多有关 Angular 中变更检查的更多信息？"></a>想要了解更多有关 Angular 中变更检查的更多信息？</h2><p>首先，阅读<a href="https://www.520stone.com/page/article/五篇让你成为Angular变化检测专家/" target="_blank" rel="noopener">These 5 articles will make you an Angular Change Detection expert.</a>.如果你想要牢固掌握 Angular 中的变化检测机制，那么这个系列是必读的。每篇文章都以前一篇文章中解释的信息为基础，然后以高级的维度讲解实现细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要深入介绍，在 Angular 中，关于如何手动控制变动改动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular7.0发布-虚拟滚动、拖拽等特性</title>
    <link href="http://blog.fedfans.com//page/article/Angular7-0%E5%8F%91%E5%B8%83-%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E3%80%81%E6%8B%96%E6%8B%BD%E7%AD%89%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.fedfans.com//page/article/Angular7-0发布-虚拟滚动、拖拽等特性/</id>
    <published>2018-10-18T23:38:06.000Z</published>
    <updated>2018-10-19T04:22:53.321Z</updated>
    
    <content type="html"><![CDATA[<p>2018年10月19日，Angular7.0发布了! 这是一个跨了major版本的版本，其中包括核心框架，Angular Material，还有Angular CLI跟主分支也进行了同步。这个版本在工具链方面提供了更多的特性，并且合并了一些主要参与者的分支的功能。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*CQKUmJrBs-523I4GOiEUaA.gif" alt=""><br>虚拟scrolling可以提高我们的应用性能</p><h1 id="如何升级到Angular7-0的版本"><a href="#如何升级到Angular7-0的版本" class="headerlink" title="如何升级到Angular7.0的版本"></a>如何升级到Angular7.0的版本</h1><p>还是跟以往一样，我们可以通过 <a href="https://update.angular.io" target="_blank" rel="noopener">https://update.angular.io</a>查看详细的文档和手册来升级我们的项目。同时告诉大家一个好消息，就是因为我们在V6.0的版本中做的工作，我们大部分的开发者可以通过一条命令就能从Angular6.0升级到Angular7.0版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng update @angular/cli @angular/core</span><br></pre></td></tr></table></figure><p>早期已经体验过这个升级过程的开发说，这次升级相比以往变得更快了，大部分升级过程仅仅花了不到10分钟就升级完了。</p><h1 id="CLI提示输入"><a href="#CLI提示输入" class="headerlink" title="CLI提示输入"></a>CLI提示输入</h1><p>现在Angular/cli工具会在当用户运行ng new 或者ng add @angular/material的时候，提示用户一些参数信息，来帮助用户使用routing或者scss功能的功能。</p><p>这个提示用户帮助创建项目的功能，已经被加入到@angular-devkit/schematics-cli这个工具中，关于schematics，又可以跳转到另一篇<a href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" target="_blank" rel="noopener">文章</a>,这样任何用schematics发布的用户可以通过添加x-promt到Schematics的配置项中。</p><p>如下schematic.json文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;routing&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;boolean&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Generates a routing module.&quot;,</span><br><span class="line">  &quot;default&quot;: false,</span><br><span class="line">  &quot;x-prompt&quot;: &quot;Would you like to add Angular routing?&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h1 id="应用性能方面"><a href="#应用性能方面" class="headerlink" title="应用性能方面"></a>应用性能方面</h1><p>还是跟以往一样，我们依旧关注着性能方面的改进，我们分析了大部分Angular生态圈这边的错误。我们发现有很多的开发者在生产环境中加入了reflect-metadata这个polyfill，这其实仅仅只需要在开发阶段加入即可。</p><p>为了解决这个问题，升级到Angular7.0的过程中，我们会自动从polyfills.ts文件中移除reflect-metadata这个，然后当我们使用JIT模式的编译的时候加入这个reflect-metadata，而在生产环境编译中默认移除这个。</p><p>在Angular7.0的版本中，我们会提醒新项目使用cli工具打包的时候，生成的包的大小。新应用，我们会在2MB大小的时候进行警告，而在5MB的时候直接报错。当然这个大小我们增加了配置项在angular.json文件中让我们进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;budgets&quot;: [&#123;</span><br><span class="line">  &quot;type&quot;: &quot;initial&quot;,</span><br><span class="line">  &quot;maximumWarning&quot;: &quot;2mb&quot;,</span><br><span class="line">  &quot;maximumError&quot;: &quot;5mb&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>关于包的提示的内容，我们会在Chrome上面进行显示。如下图:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*jXHBMok5cNnkXD8O0a8gAg.png" alt=""></p><h1 id="Angular-Material-amp-the-CDK"><a href="#Angular-Material-amp-the-CDK" class="headerlink" title="Angular Material &amp; the CDK"></a>Angular Material &amp; the CDK</h1><p>Material 设计组在2018年做了一个比较大的改动，具体改动，我们可以查看文档<a href="https://www.youtube.com/watch?v=1Dh8ZBQp9jo" target="_blank" rel="noopener">a big update</a>。Angular Material的用户在升级到Angular7.0的版本中，我们需要关注下在表现形式上面的一些微小的展示上的不同。<br>如下图：<br><img src="https://cdn-images-1.medium.com/max/1600/1*lgZYt3RBGM_c7HUcg85Zgg.png" alt=""></p><p>在angular material的CDK中，我们又利用了虚拟滚动和拖拽的功能，加入了DragDropModule或者叫Scrolling Module。</p><h2 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h2><p>虚拟滚动让DOM节点在一个list中进行加入和删除，让我们的在一个大型可滚动的应用中体验到更加流程的用户体验。</p><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;cdk-virtual-scroll-viewport itemSize=&quot;50&quot; class=&quot;example-viewport&quot;&gt;</span><br><span class="line">  &lt;div *cdkVirtualFor=&quot;let item of items&quot; class=&quot;example-item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/cdk-virtual-scroll-viewport&gt;</span><br></pre></td></tr></table></figure></p><p>如果想要了解更多关于 Virual Scrolling，可以查看<a href="https://material.angular.io/cdk/scrolling/overview" target="_blank" rel="noopener">文章</a></p><h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><p>如下图的拖拽效果:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*i30ZQdBC7CKbXXdOrUNQcg.gif" alt=""></p><p>在CDK中，我们加入了拖拽的功能，当用户移动的时候我们会自动的重绘元素就，这里又一些方法可以提供给我们，moveItemInArray，还有在列表间传送单元:transferArrayItem。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div cdkDropList class=&quot;list&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; *ngFor=&quot;let movie of movies&quot; cdkDrag&gt;&#123;&#123;movie&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop(event: CdkDragDrop&lt;string[]&gt;) &#123;</span><br><span class="line">  moveItemInArray(this.movies, event.previousIndex, event.currentIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要了解更多关于拖拽这块的，可以查看<a href="https://material.angular.io/cdk/drag-drop/overview" target="_blank" rel="noopener">文章</a></p><h1 id="同时我们优化了selects的可用性"><a href="#同时我们优化了selects的可用性" class="headerlink" title="同时我们优化了selects的可用性"></a>同时我们优化了selects的可用性</h1><p>我们通过在mat-form-field这个标签中使用原生select节点之中，提高了应用的可用性。原生的select表现出更好的性能，可用性和可获得性，但是我们也将继续保留mat-select做为mat-form-fields的内置标签使用。<br>(这个也是在Angular Material中的)</p><p>如果想要了解mat-select和mat-form-field的内容，我们可以查看<a href="https://material.angular.io/components/select/overview" target="_blank" rel="noopener">链接</a></p><h1 id="Angular-Elements"><a href="#Angular-Elements" class="headerlink" title="Angular Elements"></a>Angular Elements</h1><p>Angular Elements现在通过标准的custom elements，支持了内容的保护。<br>如下:</p><p><my-custom-element>This content can be projected!</my-custom-element></p><p>关于Angular Elements，可以看我的翻译的文章<a href="https://www.520stone.com/page/article/%E9%80%9A%E8%BF%87Angular6%E5%88%9B%E5%BB%BACustom-Elements-Web-Components/" target="_blank" rel="noopener">通过Angular6创建Custom Elements/Web Components</a></p><h1 id="Angular项目参与者提供的功能"><a href="#Angular项目参与者提供的功能" class="headerlink" title="Angular项目参与者提供的功能"></a>Angular项目参与者提供的功能</h1><p>Angular在社区这块非常感激大家的贡献，同时我们在一些社区项目中参与了，并且一些项目已经正式使用了。如下图:<br>StackBlitz 2.0 Supports multipane editing and the Angular Language Service<br><img src="https://cdn-images-1.medium.com/max/1600/1*5dDsNd840QO7btuZUsnBYw.gif" alt=""></p><p><a href="https://angularconsole.com/" target="_blank" rel="noopener">Angular Console</a>一个可以被下载的console，用来做项目启动和运行的。<br><a href="https://github.com/angular/angularfire2" target="_blank" rel="noopener">@angular/fire</a> AngularFIle有了一个新的报名，他有当前最稳定的版本<br><a href="https://docs.nativescript.org/code-sharing/intro" target="_blank" rel="noopener">NativeScript</a>通过NativeScript，让我们既能让我们项目运行成web，也能运行成可安装的手机应用。<br><a href="https://stackblitz.com/fork/angular" target="_blank" rel="noopener">StackBlitz</a>StackBlitz2.0已经发布</p><h1 id="升级手册"><a href="#升级手册" class="headerlink" title="升级手册"></a>升级手册</h1><p>我们在不断优化我们的使用手册。现在官方的angular.io中，已经包含了angular-cli的文档，文档地址:<a href="https://angular.io/cli" target="_blank" rel="noopener">地址</a></p><h1 id="依赖升级"><a href="#依赖升级" class="headerlink" title="依赖升级"></a>依赖升级</h1><p>Angular7.0依赖于Typescript3.1, RxJS6.3，Node10（我们也会支持Node8）</p><h1 id="Ivy怎么样了？"><a href="#Ivy怎么样了？" class="headerlink" title="Ivy怎么样了？"></a>Ivy怎么样了？</h1><p>我们还在努力为我们下一代的渲染引擎，Ivy努力。Ivy正在开发中，但还不是v7里面的功能。我们正在验证在一些过去应用中的可用性，并且最快的预计下个月，我们会给出Ivy的预览效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年10月19日，Angular7.0发布了! 这是一个跨了major版本的版本，其中包括核心框架，Angular Material，还有Angular CLI跟主分支也进行了同步。这个版本在工具链方面提供了更多的特性，并且合并了一些主要参与者的分支的功能。&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>通过Angular6创建Custom Elements/Web Components《翻译》</title>
    <link href="http://blog.fedfans.com//page/article/%E9%80%9A%E8%BF%87Angular6%E5%88%9B%E5%BB%BACustom-Elements-Web-Components/"/>
    <id>http://blog.fedfans.com//page/article/通过Angular6创建Custom-Elements-Web-Components/</id>
    <published>2018-09-27T15:41:25.000Z</published>
    <updated>2018-09-29T16:08:31.329Z</updated>
    
    <content type="html"><![CDATA[<p>通过新版本的Angular CLI（version 6，released 2018-04-03）和新的Angular成员（Angular Elements这个模块），让创建custom elements变得尤为简单。</p><p>如果你不知道custom elements是什么或者它跟Angular有什么关系，那大家可以查看<a href="https://www.youtube.com/watch?v=9zyq7FcIuvM&amp;feature=youtu.be" target="_blank" rel="noopener">视频教程</a>来进行了解这些内容，对这些的了解有助你对文中的内容有更多的了解。</p><p>那么，不多讲，让我们来看看代码怎么写吧~</p><h2 id="一、安装Angular-CLI-6的版本并且初始化一个工程"><a href="#一、安装Angular-CLI-6的版本并且初始化一个工程" class="headerlink" title="一、安装Angular CLI 6的版本并且初始化一个工程"></a>一、安装Angular CLI 6的版本并且初始化一个工程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @angular/cli</span><br><span class="line">ng new elements-demo --prefix custom</span><br></pre></td></tr></table></figure><p>我们并不需要做什么其他特殊的事情，为了web component那边，我们一般是需要以prefix前缀，此处相当于我们生成的web component元素，都是custom-{}这样的。</p><h2 id="二、添加-angular-elements和polyfill"><a href="#二、添加-angular-elements和polyfill" class="headerlink" title="二、添加@angular/elements和polyfill"></a>二、添加@angular/elements和polyfill</h2><p>为了能使用这个功能，我们需要引入Angular的这个组件包以及一个polyfill兼容包。操作方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng add @angular/elements</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6525544/46158492-8cf99680-c2b0-11e8-8956-dfb3974f4898.png" alt="image"></p><h2 id="三、创建一个Component"><a href="#三、创建一个Component" class="headerlink" title="三、创建一个Component"></a>三、创建一个Component</h2><p>下面我们来创建一个含有Input和Output的Component，来了解它是怎么转变为能被浏览器识别的custom elements。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g component button --inline-style --inline-template -v Native</span><br></pre></td></tr></table></figure></p><p>最终，会帮我们在src/app中生成一个文件夹button，然后里面有个ButtonComponent。</p><p>然后我们加入一些样式和模板，最终button.component.ts看起来如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, EventEmitter, Input, OnInit, Output, ViewEncapsulation&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'custom-button'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button (click)="handleClick();"&gt;&#123;&#123;label&#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  styles: [<span class="string">`</span></span><br><span class="line"><span class="string">    button&#123;</span></span><br><span class="line"><span class="string">      border: solid 3px;</span></span><br><span class="line"><span class="string">      padding: 8px 10px;</span></span><br><span class="line"><span class="string">      background: #bada55;</span></span><br><span class="line"><span class="string">      font-size: 20px;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>],</span><br><span class="line">  encapsulation: ViewEncapsulation.ShadowDom <span class="comment">// 此处我把Native改成了ShadowDom，因为Native从v6.1.0开始废弃了</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ButtonComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>() label: <span class="built_in">String</span> = <span class="string">'default label'</span>;</span><br><span class="line">  <span class="meta">@Output</span>() action: EventEmitter&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">private</span> clicksCounts = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.action.emit(<span class="keyword">this</span>.clicksCounts++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、注册Component到NgModule"><a href="#四、注册Component到NgModule" class="headerlink" title="四、注册Component到NgModule"></a>四、注册Component到NgModule</h2><p>接下来就是至关重要的一步：我们通过使用Angular里面的createCustomElement这个函数来创建一个能被浏览器原生函数customElements.define使用的class。</p><p>Angular官方文档是这么描述的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createCustomElement Builds a class that encapsulates the functionality of the provided component and uses the configuration information to provide more context to the class. Takes the component factory’s inputs and outputs to convert them to the proper custom element API and add hooks to input changes.</span><br><span class="line">The configuration’s injector is the initial injector set on the class, and used by default for each created instance.This behavior can be overridden with the static property to affect all newly created instances, or as a constructor argument for one-off creations.</span><br></pre></td></tr></table></figure></p><p>然后同时，我们需要将ButtonComponent放到entryComponents里面，然后我们把原本工程自动生成的app.component.ts这些删掉。</p><p>最终我们的app.module.ts长这个样子:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Injector, NgModule&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ButtonComponent &#125; <span class="keyword">from</span> <span class="string">'./button/button.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createCustomElement&#125; <span class="keyword">from</span> <span class="string">'@angular/elements'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    ButtonComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  entryComponents: [ButtonComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> injector: Injector</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> customButton = createCustomElement(ButtonComponent, &#123;injector&#125;);</span><br><span class="line">    customElements.define(<span class="string">'custom-button'</span>, customButton);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五、编译、压缩并测试我们的代码"><a href="#五、编译、压缩并测试我们的代码" class="headerlink" title="五、编译、压缩并测试我们的代码"></a>五、编译、压缩并测试我们的代码</h2><p>我们通过http-server来测试我们的代码，所以我们先安装下这个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i http-server -D</span><br></pre></td></tr></table></figure></p><p>通常，我们使用ng build命令来编译angular的代码，然后它会帮我们生成四个文件(runtime.js, script.js, polyfills.js和main.js)，然后我们将其合并成一个js文件，为了合并方便我们让编译出来的去hash一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build --prod --output-hashing=none</span><br></pre></td></tr></table></figure></p><p>最终生成到dist/elements-demo里面的，是四个不带hash的js文件。然后我们通过gzip然后变成一个js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dist/elements-demo/&#123;runtime,polyfills,scripts,main&#125;.js | gzip &gt; elements.js.gz</span><br></pre></td></tr></table></figure></p><p>然后我们在项目根目录下创建一个index.html文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"elements.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">custom-button</span> <span class="attr">label</span>=<span class="string">"First value"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'custom-button'</span>);</span></span><br><span class="line"><span class="javascript">  button.addEventListener(<span class="string">'action'</span>, (event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">`action emitted : <span class="subst">$&#123;event.detail&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;button.label=<span class="string">'Second Value;'</span>&#125;, <span class="number">3000</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后我们在package.json里面的scripts里面加入这几个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;ng build --prod --output-hashing=none&quot;,</span><br><span class="line">&quot;package&quot;: &quot;cat dist/elements-demo/&#123;runtime,polyfills,scripts,main&#125;.js | gzip &gt; elements.js.gz&quot;,</span><br><span class="line">&quot;serve&quot;: &quot;http-server --gzip&quot;</span><br></pre></td></tr></table></figure></p><p>然后我们通过运行 npm run build &amp;&amp; npm run package，最后运行npm run serve.<br>然后我们就能看到我们web Components的页面效果了。</p><h2 id="六、收尾"><a href="#六、收尾" class="headerlink" title="六、收尾"></a>六、收尾</h2><p>回顾下，操作中最关键的是什么？总结一下：</p><ol><li>ng add @angular/elements库</li><li>用createCustomElement创建custom elements并 customElements.define去register custom elements</li><li>合并我们生成的js文件到一个压缩包</li></ol><p>看起来并不难对吧？所以我个人也是非常激动，这是这么简单的一个过程。这将在这个使用过程中，能对原先旧项目改造的时候比较局部而简单，不需要大动干戈。</p><p>而且我们通过ls -trlh 来查看生成出来的文件的大小。elements.js.gz只有紧紧70kb，考虑到他已经涵盖了一个angular在内部，所以已经是非常可观的结果了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过新版本的Angular CLI（version 6，released 2018-04-03）和新的Angular成员（Angular Elements这个模块），让创建custom elements变得尤为简单。&lt;/p&gt;
&lt;p&gt;如果你不知道custom elements
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Koa相关源码阅读系列</title>
    <link href="http://blog.fedfans.com//page/article/Node%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    <id>http://blog.fedfans.com//page/article/Node相关源码阅读系列/</id>
    <published>2018-09-19T00:06:06.000Z</published>
    <updated>2018-09-19T04:37:06.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列篇"><a href="#系列篇" class="headerlink" title="系列篇"></a>系列篇</h2><ol><li>Koa源码(阅读进度：0%)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址: https://github.com/koajs/koa</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="2"><li>Koa-Router源码（阅读进度：100%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="3"><li>Koa-compose源码（阅读进度：100%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址: https://github.com/koajs/compose</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="4"><li>Koa-bodyparser源码（阅读进度：0%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：https://github.com/koajs/bodyparser</span><br></pre></td></tr></table></figure></li></ol><p>解析文章:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列篇&quot;&gt;&lt;a href=&quot;#系列篇&quot; class=&quot;headerlink&quot; title=&quot;系列篇&quot;&gt;&lt;/a&gt;系列篇&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Koa源码(阅读进度：0%)&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/"/>
    
      <category term="Koa" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/Koa/"/>
    
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
      <category term="源码阅读" scheme="http://blog.fedfans.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Node.js里面import和require一样吗？</title>
    <link href="http://blog.fedfans.com//page/article/Node.js%E9%87%8C%E9%9D%A2import%E5%92%8Crequire%E4%B8%80%E6%A0%B7%E5%90%97/"/>
    <id>http://blog.fedfans.com//page/article/Node.js里面import和require一样吗/</id>
    <published>2018-09-10T12:28:31.000Z</published>
    <updated>2018-09-10T13:32:10.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>本文主要讲解内容：import * as http from ‘http’; 和 const http = require(‘http’)这两种写法是否效果是相同的？</p><h2 id="问题场景篇"><a href="#问题场景篇" class="headerlink" title="问题场景篇"></a>问题场景篇</h2><p>我的ts的代码遇到一个情况，import * as http from ‘http’; 和 const http = require(‘http’)，这两个表现不一样。</p><p>如下代码: </p><p>A.ts<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shimmer <span class="keyword">from</span> <span class="string">'shimmer'</span>;</span><br><span class="line"></span><br><span class="line">shimmer.wrap(http, <span class="string">'createServer'</span>, <span class="function"><span class="params">original</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, requestListener: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"====&gt;"</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"2222"</span>)</span><br><span class="line">       <span class="comment">// 此处hook最底层的http,createServer</span></span><br><span class="line">       <span class="comment">// @ts-ignore</span></span><br><span class="line">       <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>A.ts是我封装的代码精简版，内部我使用shimmer对这个http的createServer这个函数进行hook，然后方便做代码http接口调用情况的统计。</p><p>然后main.ts是业务系统里面的代码，内部我们常常使用的是var koa = require(‘koa’)，koa底层肯定是http的createServer，所以我们此处用var http = require(‘http’)来模拟。</p><p>main.ts(业务代码里面，假设是require(‘http’))<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = http.createServer(<span class="function">(<span class="params">req: <span class="built_in">any</span>, res : <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.end(<span class="string">'okay'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行后发现A.ts包里面如果我用import * as http from ‘http’ 不能hook对应的createServer的代码，但是我用const http = require(‘http’)就可以hook。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>然后将对应的ts代码编译代码后，发现import 的代码编译成了下面这种代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __importStar = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__importStar) || <span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mod &amp;&amp; mod.__esModule) <span class="keyword">return</span> mod;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (mod != <span class="literal">null</span>) <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> mod) <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(mod, k)) result[k] = mod[k];</span><br><span class="line">    result[<span class="string">"default"</span>] = mod;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> http = __importStar(<span class="built_in">require</span>(<span class="string">"http"</span>));</span><br></pre></td></tr></table></figure></p><p>按理，如我们标题一样，不应该是import * as http from ‘http’，应该等于const http= require(‘http’)吗?所以为何不是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br></pre></td></tr></table></figure></p><p>呢？不然我hook的其实是这个<strong>importStar里面这个result这个新的{}对象上面的createServer这个函数。那我们谷歌查询</strong>importStar，</p><p>最终，查到原来是ts的配置项中的esModuleInterop被设置成了true导致的。我们查看tsconfig.json文件里面的描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &apos;allowSyntheticDefaultImports&apos;</span><br></pre></td></tr></table></figure></p><p>相当于是为了做一个CommonJS和es modules这边的一个互通，会帮忙新建一个namespace objects。所以相当于这个__importStar是为了跟es modules那边有关系。</p><p>解决办法:把tsconfig.json里面这个特性关掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esModuleInterop: false</span><br></pre></td></tr></table></figure></p><h2 id="继续深入了解"><a href="#继续深入了解" class="headerlink" title="继续深入了解"></a>继续深入了解</h2><p>那我们就去看一下babel那块对于import这块的处理，我们写一个main.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure></p><p>然后项目安装babel的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br><span class="line"></span><br><span class="line"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span><br><span class="line">$ npm install --save-dev babel-preset-stage-0</span><br><span class="line">$ npm install --save-dev babel-preset-stage-1</span><br><span class="line">$ npm install --save-dev babel-preset-stage-2</span><br><span class="line">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure></p><p>然后新建一个文件.babelrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;es2015&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们通过调用babel main.js –out-file out.js,查看过babel之后的这个包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = _interopRequireWildcard(_http);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireWildcard</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) &#123; <span class="keyword">return</span> obj; &#125; <span class="keyword">else</span> &#123; <span class="keyword">var</span> newObj = &#123;&#125;; <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123; <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123; <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; &#125; &#125; newObj.default = obj; <span class="keyword">return</span> newObj; &#125; &#125;</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure><p>然后我们也看到了一个类似__importStar这样的函数，也就是_interopRequireWildcard，也是内部去创建了一个{}这个对象。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以我们最终可以得到一个结论，babel这边<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br></pre></td></tr></table></figure></p><p>其实跟const http = require(‘http’)是有区别的，babel这边会帮我们生成一个类似namespace这样的东西。相当于这个文件里面里面http是处于一个namespace里面的，两个文件都import * as http from ‘http’; 如果其中一个文件修改了，则另外一个是不会被修改的。</p><p>然后typescript编译器那边，给我们加了这样一个属性，就是是否需要这种特性，也就是配置项: esModuleInterop</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那对于我的需求来说，我是为了让调用这个npm方的人，对于大家调用的底层的http包进行hook，所以我不希望有这样一个namespace包起来，所以我的ts代码里面就需要把这个esModuleInterop给关闭掉。最终编译后的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="comment">//简称这个地方不会帮我们包一层namespace</span></span><br></pre></td></tr></table></figure><p>所以Node.js里面，typescript，关于模块引用，我们可以选择用es module的形式去引用一个包，也可以用commonJS的方式去引用一个包，如果你是用es6在写。那es6那边你import了一个包，那就会多一个namespace这样的东西。如果有不对，请帮忙指正下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;本文主要讲解内容：import * as http from ‘http’; 和 const http = require(
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/"/>
    
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
      <category term="问题" scheme="http://blog.fedfans.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Pandora源码-Pandora-dashboard(一)</title>
    <link href="http://blog.fedfans.com//page/article/Pandora%E6%BA%90%E7%A0%81-Pandora-dashboard(%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.fedfans.com//page/article/Pandora源码-Pandora-dashboard(一）/</id>
    <published>2018-08-29T14:13:18.000Z</published>
    <updated>2018-08-30T16:40:09.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pandora是阿里，一个可管理、可度量、可追踪的Node.js应用管理器。文档地址：<a href="http://www.midwayjs.org/pandora/zh-cn/" target="_blank" rel="noopener">http://www.midwayjs.org/pandora/zh-cn/</a> ，<br>仓库地址：<a href="https://github.com/midwayjs/pandora/" target="_blank" rel="noopener">https://github.com/midwayjs/pandora/</a> 和  <a href="https://github.com/midwayjs/pandora-dashboard。" target="_blank" rel="noopener">https://github.com/midwayjs/pandora-dashboard。</a></p><h2 id="Pandora-dashboard介绍"><a href="#Pandora-dashboard介绍" class="headerlink" title="Pandora-dashboard介绍"></a>Pandora-dashboard介绍</h2><p>这个是对应的Pandora的一个web应用，用来查看pandora应用管理器里面应用的情况。运行方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i pandora-dashboard -g # 全局安装，会全局注册一个命令 pandora-dashboard-dir</span><br><span class="line">$ pandora start --name dashboard `pandora-dashboard-dir` # 使用该命令获得路径，用于启动</span><br></pre></td></tr></table></figure></p><p>然后访问网址: <a href="http://127.0.0.1:9081/" target="_blank" rel="noopener">http://127.0.0.1:9081/</a>, 他的网页效果：</p><p><img src="https://user-images.githubusercontent.com/6525544/44789504-4c363100-abcf-11e8-9066-6501928f257a.png" alt=""></p><p>浏览器通过9801端口访问这个dashboard，Dashboard内部的结构总体如下图：</p><p><img src="https://user-images.githubusercontent.com/6525544/44789098-54da3780-abce-11e8-8814-e2eec12211ff.png" alt=""></p><p>然后这个代码比较简单，总体是一个typescript写的一个koa程序，然后项目结构如下图:</p><p><img src="https://user-images.githubusercontent.com/6525544/44789590-8d2e4580-abcf-11e8-8b0e-6e839bab9254.png" alt=""></p><p>Impl文件夹内部是对应的router，然后Home会去取上面的html相关的，static取对应的js，css相关的。然后Actuator.ts则是调用7002端口里面的信息。<br>Stdout，DebuggerProxy都新建了对应的websocket跟后端进行通信输出对应信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体我们看到dashboard这层，不像PM2那边的server是做了中心化存储，可以在中心进行查看各机器的信息。而Pandora当前是单机器装对应的Pandora和Pandora-dashboard，无法关于多台机器上面的Pandora的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Pandora是阿里，一个可管理、可度量、可追踪的Node.js应用管理器。文档地址：&lt;a href=&quot;http://www.midwayj
      
    
    </summary>
    
      <category term="Pandora源码分析" scheme="http://blog.fedfans.com/categories/Pandora%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pandora" scheme="http://blog.fedfans.com/tags/Pandora/"/>
    
      <category term="NodeJs" scheme="http://blog.fedfans.com/tags/NodeJs/"/>
    
      <category term="Node监控" scheme="http://blog.fedfans.com/tags/Node%E7%9B%91%E6%8E%A7/"/>
    
      <category term="JavaScript" scheme="http://blog.fedfans.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我博客的前世今生</title>
    <link href="http://blog.fedfans.com//page/article/%E6%88%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.fedfans.com//page/article/我博客的前世今生/</id>
    <published>2018-08-28T14:13:18.000Z</published>
    <updated>2018-08-31T04:22:26.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我博客的前世今生"><a href="#我博客的前世今生" class="headerlink" title="我博客的前世今生"></a>我博客的前世今生</h2><p>原来的博客是非静态，是用vue的nuxtjs的ssr渲染，<a href="http://www.520stone.com" target="_blank" rel="noopener">www.520stone.com</a> ，后台是springboot+spring cloud相关技术栈全部手写的。<br>现在迁移到github page里面，不然每次要续费服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我博客的前世今生&quot;&gt;&lt;a href=&quot;#我博客的前世今生&quot; class=&quot;headerlink&quot; title=&quot;我博客的前世今生&quot;&gt;&lt;/a&gt;我博客的前世今生&lt;/h2&gt;&lt;p&gt;原来的博客是非静态，是用vue的nuxtjs的ssr渲染，&lt;a href=&quot;http://w
      
    
    </summary>
    
      <category term="日常杂记" scheme="http://blog.fedfans.com/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="http://blog.fedfans.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杂记" scheme="http://blog.fedfans.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于服务器上面搭建了gitlab遇到的问题</title>
    <link href="http://blog.fedfans.com//page/article/45/"/>
    <id>http://blog.fedfans.com//page/article/45/</id>
    <published>2018-07-12T14:35:14.000Z</published>
    <updated>2018-08-31T05:34:28.039Z</updated>
    
    <content type="html"><![CDATA[<p>原先在自己电脑搭建了gitlab私服，但是由于要使用gitlab-ci，所以我就在阿里云服务器上面搭建了gitlab私服。</p><p>问题一：gitlab私服卡啊？</p><p>所以解决这个问题，就升级配置，当前使用了1G 2G内存，同时配置对应的swap，最终解决，如果服务器配置很差，升个级吧。</p><p>问题二：gitlab-ci的过程中，开头配置在相同电脑，然后一旦我提交了代码后，gitlab就无法访问了，同时我的站点也无法访问了？</p><p>首先我想法：cpu，带宽。</p><p>带宽：那我配置下我gitlab域名的host，这样可以通过127.0.0.1走本地，那带宽就不用占用我的带宽了，毕竟带宽这么贵。</p><p>cpu：处理了上面这种情况，问题还是在，那想法cpu，就是执行我的部署脚本的时候cpu占用大。后来发现这个好像并不影响。</p><p>最后发现是编译过程比较耗cpu，所以最终我把这个编译，放到一个小阿里云服务器，配置一个gitlab-runner解决。</p><p>最终，代码提交，执行gitlab-ci操作，编译部署，完美~不会影响gitlab和自己站点的访问了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原先在自己电脑搭建了gitlab私服，但是由于要使用gitlab-ci，所以我就在阿里云服务器上面搭建了gitlab私服。&lt;/p&gt;
&lt;p&gt;问题一：gitlab私服卡啊？&lt;/p&gt;
&lt;p&gt;所以解决这个问题，就升级配置，当前使用了1G 2G内存，同时配置对应的swap，最终解决，
      
    
    </summary>
    
      <category term="问题篇" scheme="http://blog.fedfans.com/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
    
      <category term="Gitlab" scheme="http://blog.fedfans.com/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器配置swap分区</title>
    <link href="http://blog.fedfans.com//page/article/44/"/>
    <id>http://blog.fedfans.com//page/article/44/</id>
    <published>2018-07-11T14:52:16.000Z</published>
    <updated>2018-08-31T05:30:13.365Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yq.aliyun.com/articles/52098" target="_blank" rel="noopener">https://yq.aliyun.com/articles/52098</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/52098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/articles/52098&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="服务器" scheme="http://blog.fedfans.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://blog.fedfans.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于大型angular项目编译问题</title>
    <link href="http://blog.fedfans.com//page/article/43/"/>
    <id>http://blog.fedfans.com//page/article/43/</id>
    <published>2018-07-11T14:11:25.000Z</published>
    <updated>2018-10-13T06:19:52.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当angular项目比较庞大的时候，打包时间就会比较慢。然后这个时候会出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[22517:0x102802400]   176590 ms: Mark-sweep 1367.9 (1430.1) -&gt; 1367.9 (1430.1) MB, 1351.8 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[22517:0x102802400]   178544 ms: Mark-sweep 1367.9 (1430.1) -&gt; 1367.9 (1427.1) MB, 1771.4 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[22517:0x102802400]   180071 ms: Mark-sweep 1367.9 (1427.1) -&gt; 1367.9 (1427.1) MB, 1526.6 / 0.0 ms  last resort GC in old space requested</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">Security context: 0x2f04b2e25529 &lt;JSObject&gt;</span><br><span class="line">    1: forEachChild [/Users/stone-jin/Downloads/metronic_v5.2 3/metronic_v5.2/angular/dist/demo/default/node_modules/typescript/lib/typescript.js:~11931] [pc=0x305175bbd919](this=0x2f04ace04a51 &lt;Object map = 0x2f04b1451ae9&gt;,node=0x2f04692c72a1 &lt;NodeObject map = 0x2f04352d8e11&gt;,cbNode=0x2f0421f75a69 &lt;JSFunction visitNode (sfi = 0x2f0414f144b9)&gt;,cbNodes=0x2f04fc6822d1 &lt;undefined&gt;)</span><br><span class="line">    2: arguments...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br><span class="line"> 1: node::Abort() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 2: node::FatalTryCatch::~FatalTryCatch() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 3: v8::internal::V8::FatalProcessOutOfMemory(char const*, bool) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 4: v8::internal::Factory::NewCodeRaw(int, bool) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 5: v8::internal::Factory::NewCode(v8::internal::CodeDesc const&amp;, unsigned int, v8::internal::Handle&lt;v8::internal::Object&gt;, bool, int) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 6: v8::internal::CodeGenerator::MakeCodeEpilogue(v8::internal::TurboAssembler*, v8::internal::EhFrameWriter*, v8::internal::CompilationInfo*, v8::internal::Handle&lt;v8::internal::Object&gt;) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 7: v8::internal::compiler::CodeGenerator::FinalizeCode() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 8: v8::internal::compiler::PipelineImpl::FinalizeCode() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 9: v8::internal::compiler::PipelineCompilationJob::FinalizeJobImpl() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">10: v8::internal::Compiler::FinalizeCompilationJob(v8::internal::CompilationJob*) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">11: v8::internal::OptimizingCompileDispatcher::InstallOptimizedFunctions() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">12: v8::internal::StackGuard::HandleInterrupts() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">13: v8::internal::Runtime_StackGuard(int, v8::internal::Object**, v8::internal::Isolate*) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">14: 0x305174e042fd</span><br><span class="line">15: 0x305175bbd919</span><br></pre></td></tr></table></figure></p><p>这样的错误信息，不要慌张，这种通用类型的最简单，搜索下就好。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>大概就是编译慢了，node认为我们有内存泄漏了。所以这个时候我们只要通过- -max-old-space-size=4096 这个来解决我们的问题即可。这个修改在node_modules/.bin下面有个ng文件。然后我们修改这个文件。</p><p>在头部的#!/usr/bin/env node之后加上- -max-old-space-size=4096就可以解决我们的问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当angular项目比较庞大的时候，打包时间就会比较慢。然后这个时候会出现&lt;br&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="问题篇" scheme="http://blog.fedfans.com/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="编译报错" scheme="http://blog.fedfans.com/tags/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>服务器安装maven环境</title>
    <link href="http://blog.fedfans.com//page/article/42/"/>
    <id>http://blog.fedfans.com//page/article/42/</id>
    <published>2018-07-11T13:47:29.000Z</published>
    <updated>2018-08-31T14:43:08.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>由于我现在server端使用springboot进行开发，所以maven编译这步肯定必不可少。</p><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><p>打开maven官网：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>然后拷贝下载地址，去服务器上面wget下来。</p><p>然后使用tar zxvf <strong><em>.tar.gz包，然后ln -s apache-maven-</em></strong> apache-maven创建软连接，方便升级</p><p>然后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/home/software/apache-maven</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>然后我们执行mvn -v查看下我们的maven环境是否正确。</p><p>至此我们maven已经安装完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;由于我现在server端使用springboot进行开发，所以maven编译这步肯定必不可少。&lt;/p&gt;
&lt;h2 id=&quot;二、
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="Maven" scheme="http://blog.fedfans.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>服务器安装node环境</title>
    <link href="http://blog.fedfans.com//page/article/41/"/>
    <id>http://blog.fedfans.com//page/article/41/</id>
    <published>2018-07-11T12:17:06.000Z</published>
    <updated>2018-08-31T14:43:23.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>我们的服务器上面，前端代码或者写nodejs的时候，我们需要安装nodejs。有几种方法可以安装，推荐使用官网下载nodejs的版本。</p><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><p>方法一：（不推荐，因为安装的版本比较旧）</p><p>使用yum install nodejs</p><p>方法二：（推荐）</p><p>1、 从官网进行下载稳定版本的nodejs，官网地址：</p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p>2、然后下载linux 二进制文件。</p><p>然后服务器上面使用</p><p>wget 下载地址（这个地址是右键得到下载地址）</p><p>3、然后下载到的是tar.xz包</p><p>然后我们使用解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -d ***.tar.xz</span><br></pre></td></tr></table></figure></p><p>然后会变成.tar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf ***.tar</span><br></pre></td></tr></table></figure></p><p>然后就解压完成了。</p><p>4、然后可以创建一个软连接，方便以后升级,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s node-**** node</span><br></pre></td></tr></table></figure></p><p>5、然后我们vim /etc/profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/home/software/node(此处是大家放在那个路径)</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin</span><br></pre></td></tr></table></figure><p>6、然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>7、我们确认下我们的环境是否安装好了，执行node -v 和npm -v</p><p>方法三：（方法一般）</p><p>下载源码包，也是方法二的地址，然后./configure &amp;&amp; make &amp;&amp; make install，请确保有安装环境的一些工具。新的服务器一般用方法二比较好。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>前面三种方法，个人还是建议使用方法二，也不麻烦。如果自己电脑环境比较全，那方法三也很快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;我们的服务器上面，前端代码或者写nodejs的时候，我们需要安装nodejs。有几种方法可以安装，推荐使用官网下载nodej
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的gitlab服务以及gitlab-ci的开发模式</title>
    <link href="http://blog.fedfans.com//page/article/39/"/>
    <id>http://blog.fedfans.com//page/article/39/</id>
    <published>2018-07-10T05:13:20.000Z</published>
    <updated>2018-08-31T14:53:42.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>本地我自己肯定是搭建了自己的gitlab仓库的。这次主要是出于gitlab-ci的考虑，想要在把原本自己的ci流程，从本地的jenkins转义到gitlab-ci上，只需要提交代码，就能部署到我自己的服务器上面，并且希望是能区分预发布服和线上服两种环境，本地就当开发环境了。测试环境就不搞了，预发布就当测试环境用好了。所以本次目的，就是在自己的阿里云上面搭建自己的gitlab服务，域名就选择使用gitlab.fedfans.com这个域名好了。</p><h2 id="二、搭建过程"><a href="#二、搭建过程" class="headerlink" title="二、搭建过程"></a>二、搭建过程</h2><p>搭建过程主要涉及到几步：</p><ul><li>docker环境搭建（因为拿的是新的一台阿里云机器）</li><li>gitlab docker镜像运行</li><li>然后gitlab-ci的runner搭建</li><li>测试整个gitlab-ci的流程</li></ul><p>第一步：</p><p>docker官方提供了centos环境里面怎么安装docker。<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p>第二步:</p><p>gitlab官方提供了如果使用docker安装gitlab的环境。</p><p>第三步:</p><p>3.1 根据环境安装gitlab runner, <a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/</a></p><p>3.2 然后使用linux的安装方法。<a href="https://docs.gitlab.com/runner/install/linux-manually.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/install/linux-manually.html</a></p><p>3.3 然后我们使用gitlab-runner register</p><p>他会提示我们输入gitlab地址，这个在项目的CI/CD pipelines上面有个url和token我们分别输入到gitlab-runner register中，同时使用shell模式</p><p>3.4 然后会在当前这个目录下生成一个config.toml文件</p><p>3.5 我们修改这个config.toml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 1修改为concurrent=8</span><br></pre></td></tr></table></figure><p>3.6 然后我们使用这个shell脚本进行启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line"># chkconfig: - 99 01</span><br><span class="line"># description: GitLab Runner</span><br><span class="line"># processname: /usr/bin/gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">name=&quot;yydbhz&quot;</span><br><span class="line">desc=&quot;yydbhz&quot;</span><br><span class="line">user=&quot;&quot;</span><br><span class="line">cmd=/home/root/.gitlab-runner/gitlab-runner</span><br><span class="line">args=&quot; &quot;run&quot; &quot;--working-directory&quot; &quot;/home/root/.gitlab-runner&quot; &quot;--config&quot; &quot;/home/root/.gitlab-runner/config.toml&quot; &quot;--service&quot; &quot;gitlab-runner&quot;  &quot;--syslog&quot;&quot;</span><br><span class="line">lockfile=/home/root/.gitlab-runner/$name</span><br><span class="line">pidfile=/home/root/.gitlab-runner/$name.pid</span><br><span class="line"></span><br><span class="line"># Source networking configuration.</span><br><span class="line">[ -r /etc/sysconfig/$name ] &amp;&amp; . /etc/sysconfig/$name</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    echo -n $&quot;Starting $desc: &quot;</span><br><span class="line">    daemon \</span><br><span class="line">         \</span><br><span class="line">         \</span><br><span class="line">        &quot;$cmd $args &lt;/dev/null &gt;/dev/null 2&gt;/dev/null &amp; echo \$! &gt; $pidfile&quot;</span><br><span class="line">    retval=$?</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile</span><br><span class="line">    echo</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping $desc: &quot;</span><br><span class="line">    killproc -p $pidfile $cmd -TERM</span><br><span class="line">    retval=$?</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile</span><br><span class="line">    rm -f $pidfile</span><br><span class="line">    echo</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $desc: &quot;</span><br><span class="line">    killproc -p $pidfile $cmd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">force_reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status -p $pidfile $cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || exit 7</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>然后我们使用这个脚本进行启动。</p><p>最终gitlab-ci搭建完毕。</p><p>然后gitlab-ci的使用，我们后面讲解下。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>jenkins的流程，用了不少时间了，关于工程化个人也是比较熟练了。然后本次呢主要想要更快更敏捷的开发，同时在ci的流程中比如将部署还能选择预发布和线上这种区分，所以很方便，虽然放到阿里云服务器，带来的是上传代码变慢，这个总能解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;本地我自己肯定是搭建了自己的gitlab仓库的。这次主要是出于gitlab-ci的考虑，想要在把原本自己的ci流程，从本地的
      
    
    </summary>
    
      <category term="工程化" scheme="http://blog.fedfans.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Gitlab" scheme="http://blog.fedfans.com/tags/Gitlab/"/>
    
      <category term="工程化" scheme="http://blog.fedfans.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务器资源有限，所以给服务器配置下swap</title>
    <link href="http://blog.fedfans.com//page/article/40/"/>
    <id>http://blog.fedfans.com//page/article/40/</id>
    <published>2018-07-10T05:13:20.000Z</published>
    <updated>2018-08-31T14:45:11.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我们的服务器资源比较有限，所以我们需要节约资源，swap能让我们机器发挥更大的作用，否则分分钟报表。</p><p>文档：</p><p><a href="https://help.aliyun.com/knowledge_detail/42534.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/42534.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;我们的服务器资源比较有限，所以我们需要节约资源，swap能让我们机器发挥更大的作用，否则分分钟报表。&lt;/p&gt;
&lt;p&gt;文档：&lt;
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Swap" scheme="http://blog.fedfans.com/tags/Swap/"/>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于let sencrypt过期的问题处理</title>
    <link href="http://blog.fedfans.com//page/article/38/"/>
    <id>http://blog.fedfans.com//page/article/38/</id>
    <published>2018-06-25T15:46:44.000Z</published>
    <updated>2018-08-31T14:57:03.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题介绍"><a href="#一、问题介绍" class="headerlink" title="一、问题介绍"></a>一、问题介绍</h2><p>由于当前站点的https采用的是let sencrpt，let sencrpt是每90天需要认证一下，然后最近发现我的https过期了，然后在服务器上面执行我的续期脚本，也报错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./letsencrypt-auto certonly --renew-by-default --email hzjinbing@163.com -d www.520stone.com</span><br></pre></td></tr></table></figure></p><p>然后报错内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line"></span><br><span class="line">How would you like to authenticate with the ACME CA?</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">1: Apache Web Server plugin - Beta (apache)</span><br><span class="line">2: Nginx Web Server plugin - Alpha (nginx)</span><br><span class="line">3: Spin up a temporary webserver (standalone)</span><br><span class="line">4: Place files in webroot directory (webroot)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Select the appropriate number [1-4] then [enter] (press &apos;c&apos; to cancel): 2</span><br><span class="line">Plugins selected: Authenticator nginx, Installer None</span><br><span class="line">Renewing an existing certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">tls-sni-01 challenge for www.520stone.com</span><br><span class="line">Waiting for verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line">Failed authorization procedure. www.520stone.com (tls-sni-01): urn:acme:error:unauthorized :: The client lacks sufficient authorization :: Incorrect validation certificate for tls-sni-01 challenge. Requested 8b01252f05bfcb35a2d586933f89613e.d6b3afaf871b282ab64f7c74c0886f2f.acme.invalid from 139.196.95.206:443. Received 2 certificate(s), first certificate had names &quot;www.520stone.com&quot;</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - The following errors were reported by the server:</span><br><span class="line"></span><br><span class="line">   Domain: www.520stone.com</span><br><span class="line">   Type:   unauthorized</span><br><span class="line">   Detail: Incorrect validation certificate for tls-sni-01 challenge.</span><br><span class="line">   Requested</span><br><span class="line">   8b01252f05bfcb35a2d586933f89613e.d6b3afaf871b282ab64f7c74c0886f2f.acme.invalid</span><br><span class="line">   from 139.196.95.206:443. Received 2 certificate(s), first</span><br><span class="line">   certificate had names &quot;www.520stone.com&quot;</span><br><span class="line"></span><br><span class="line">   To fix these errors, please make sure that your domain name was</span><br><span class="line">   entered correctly and the DNS A/AAAA record(s) for that domain</span><br><span class="line">   contain(s) the right IP address.</span><br></pre></td></tr></table></figure><p>所以报错已经在这边了，我们就需要解决他，否则当前博客本来好不容易积累的每天的dau就降下来了。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>当前还未解决，最近记录下这个解决过程。</p><p>最终阿里云服务器上面过了几天后，我使用下面这个代码最终续期成功了。先记录下这个脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">../code/letsencrypt/letsencrypt-auto certonly --renew-by-default --email hzjinbing@163.com -d www.520stone.com</span><br></pre></td></tr></table></figure><p>然后最终我是使用nginx，所以中间有一个项，选择2是nginx，然后回车后最终续期成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、问题介绍&quot;&gt;&lt;a href=&quot;#一、问题介绍&quot; class=&quot;headerlink&quot; title=&quot;一、问题介绍&quot;&gt;&lt;/a&gt;一、问题介绍&lt;/h2&gt;&lt;p&gt;由于当前站点的https采用的是let sencrpt，let sencrpt是每90天需要认证一下，然后最
      
    
    </summary>
    
      <category term="服务器配置" scheme="http://blog.fedfans.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="服务器" scheme="http://blog.fedfans.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="环境配置" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>（maven系列）编写第一个maven插件</title>
    <link href="http://blog.fedfans.com//page/article/37/"/>
    <id>http://blog.fedfans.com//page/article/37/</id>
    <published>2018-06-13T12:37:13.000Z</published>
    <updated>2018-08-31T15:06:04.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近在做接口管理平台的事情，接口管理平台的方案，采用后端java项目集成swagger，然后将swagger离线化部署到接口管理平台上。然后前端在这个平台上，可以查看后端定义的接口，同时平台上提供对应的mock数据，还可以根据这个接口生成前端的sdk，不需要再去关心ajax那块。当后端接口变动的时候，我们只需要生成新的前端的SDK。</p><p>然后问题是，为了能让后端项目不需要改动，想法：如果到了class级别肯定已经无法获取到其中的javadoc的注释了，那想的时候，就是要么做一个maven的plugin，要么做一个intellij的插件。所以本文先做技术积累，做一个maven的插件试试。</p><h2 id="二、maven插件开发入门"><a href="#二、maven插件开发入门" class="headerlink" title="二、maven插件开发入门"></a>二、maven插件开发入门</h2><p>第一步：</p><p>通过intellij idea新建一个maven工程</p><p>第二步：</p><p>修改pom.xml文件，将packaging设置为maven-plugin</p><p>第三步：</p><p>我们平常执行的mvn <strong>*</strong>的操作，我们其实在执行Mojo，</p><p>所以我们新建我们第一个MoJo，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@goal</span> buildinfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@phase</span>  pre-integration-test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildInfoMojo</span> <span class="keyword">extends</span> <span class="title">AbstractMojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@parameter</span> expression="$&#123;project&#125;"</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MavenProject mavenProject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@parameter</span> expression="$&#123;buildinfo.prefix&#125;"</span></span><br><span class="line"><span class="comment">     * default-value="+++"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现其中接口类里面的execute函数，此处我们打印一下我们执行mvn时候，代码路径和输出的路径，和测试代码路径和测试结果输出的路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    Build build = mavenProject.getBuild();</span><br><span class="line">    String outputDirectory = build.getOutputDirectory();</span><br><span class="line">    String sourceDirectory = build.getSourceDirectory();</span><br><span class="line">    String testOutputDirectory = build.getTestOutputDirectory();</span><br><span class="line">    String testSourceDirectory = build.getTestSourceDirectory();</span><br><span class="line">    getLog().info(<span class="string">"\n==============\n Project build info."</span>);</span><br><span class="line"></span><br><span class="line">    String[] info = &#123;outputDirectory, sourceDirectory, testOutputDirectory, testSourceDirectory&#125;;</span><br><span class="line">    <span class="keyword">for</span>(String item: info)&#123;</span><br><span class="line">        getLog().info(<span class="string">"\t"</span>  + <span class="string">"   "</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">    getLog().info(<span class="string">"============="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编写完毕后，我们本地通过mvn clean install安装到本地的maven环境中。</p><p>然后就此我们已经编写完一个最简单的maven插件了。</p><p>第四步：测试下我们的插件：</p><p>通过执行mvn {groupId}:{artifactId}:{version}:buildinfo</p><p>最终我们可以看到下面这样的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building demo-maven-plugin <span class="number">1.0</span>-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- demo-maven-plugin:<span class="number">1.0</span>-SNAPSHOT:buildinfo (<span class="keyword">default</span>-cli) @ demo-maven-plugin ---</span><br><span class="line">[INFO] </span><br><span class="line">==============</span><br><span class="line"> Project build info.</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/target/classes</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/src/main/java</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/target/test-classes</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/src/test/java</span><br><span class="line">[INFO] =============</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">0.488</span> s</span><br><span class="line">[INFO] Finished at: <span class="number">2018</span>-<span class="number">06</span>-<span class="number">13</span>T20:<span class="number">13</span>:<span class="number">55</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">9</span>M/<span class="number">245</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>就此我们第一个maven插件书写完毕</p><p>然后我们再将我们的maven插件发布到maven仓库中，这个发布，可以通过查看：<a href="https://www.520stone.com/page/article/34" target="_blank" rel="noopener">https://www.520stone.com/page/article/34</a></p><p>最后我们新建一个springboot的工程测试下：</p><p>放在pom包里面的build里面的plugins里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">   &lt;groupId&gt;com.netease.mail&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;demo-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>然后我们再执行下我们的maven的操作，完美可以运行</p><p>同时我们可以在intellij idea右边有个maven project中，里面有个plugins可以看到我们写的buildinfo的插件在那里。</p><p>三、结束语<br>最近好久没有写文章，哈哈哈，写起来~</p><p>这个代码放在：<a href="https://github.com/stone-jin/demo-maven-plugins" target="_blank" rel="noopener">https://github.com/stone-jin/demo-maven-plugins</a> 上了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;最近在做接口管理平台的事情，接口管理平台的方案，采用后端java项目集成swagger，然后将swagger离线化部署到接口
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JAVA" scheme="http://blog.fedfans.com/tags/JAVA/"/>
    
      <category term="MAVEN" scheme="http://blog.fedfans.com/tags/MAVEN/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目指定仓库地址</title>
    <link href="http://blog.fedfans.com//page/article/36/"/>
    <id>http://blog.fedfans.com//page/article/36/</id>
    <published>2018-05-16T02:55:47.000Z</published>
    <updated>2018-08-31T15:09:03.950Z</updated>
    
    <content type="html"><![CDATA[<p>项目中，我们会遇到maven项目，从阿里的maven仓库下载加速我们的，当然可能出现比如下载springboot，springcloud比较新的版本无法下载的问题，还有有些私有包发布在我们的私有maven仓库中。</p><p>这个时候我们应该怎么做呢？</p><p>在pom.xml中指定repository的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;maven&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Official Maven Repository&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt;</span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>然后我们就又可以下载对应的包了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目中，我们会遇到maven项目，从阿里的maven仓库下载加速我们的，当然可能出现比如下载springboot，springcloud比较新的版本无法下载的问题，还有有些私有包发布在我们的私有maven仓库中。&lt;/p&gt;
&lt;p&gt;这个时候我们应该怎么做呢？&lt;/p&gt;
&lt;p&gt;在p
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JAVA" scheme="http://blog.fedfans.com/tags/JAVA/"/>
    
      <category term="MAVEN" scheme="http://blog.fedfans.com/tags/MAVEN/"/>
    
  </entry>
  
  <entry>
    <title>搭建maven的私有仓库</title>
    <link href="http://blog.fedfans.com//page/article/35/"/>
    <id>http://blog.fedfans.com//page/article/35/</id>
    <published>2018-05-14T12:06:36.000Z</published>
    <updated>2018-08-31T15:13:36.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>随着工作年限的增长，个人用过python的pip仓库，前端的npm仓库，java的pom仓库。也体验过没有中心仓库管理的，C++类似下载一个tar.gz包，然后获取头文件和lib或者so，进行调用第三方库。感想就是，使用这些库是多么的方便，能高效的提升我们的开发效率。所以本文就来搭建一个maven仓库，并且来发布我们的第一个pom包。</p><h2 id="二、搭建"><a href="#二、搭建" class="headerlink" title="二、搭建"></a>二、搭建</h2><p>这年头使用docker是多么的方便，所以我们自然而言，想的是搜索下能不能使用docker来搭建我们的maven仓库。搜索后，我们找到sonatype/nexus。</p><p>最终我们找到资料：<a href="https://hub.docker.com/r/sonatype/nexus/" target="_blank" rel="noopener">https://hub.docker.com/r/sonatype/nexus/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 --name nexus sonatype/nexus:oss</span><br></pre></td></tr></table></figure><p>然后我们装完后，访问网页看看能不能访问了：</p><p>打开网址：<a href="http://localhost:8081/nexus/#welcome" target="_blank" rel="noopener">http://localhost:8081/nexus/#welcome</a></p><p>然后我们能看到下面的效果：</p><p><img src="https://520stone-blog.oss-cn-beijing.aliyuncs.com/upload/2018-05-14T12:02:48Z/688b1d8e-6e60-4dce-8cb7-8ea09899fcd8.png" alt=""></p><p>然后我们点击右上角的登录，使用一下默认的账号试一下：admin/admin123</p><p>然后发包过程，看我上一篇的文章</p><p><a href="https://www.520stone.com/page/article/34" target="_blank" rel="noopener">《maven发布项目到私服-snapshot快照库和release发布库的区别和作用及maven常用命令》</a></p><p>三、总结<br>搭建了自己的maven仓库，并将自己的代码复用后，极大的提升了自己的代码复用，同时做的基础组件能提供给组里或者部门的其他同事使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;随着工作年限的增长，个人用过python的pip仓库，前端的npm仓库，java的pom仓库。也体验过没有中心仓库管理的，C
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JAVA" scheme="http://blog.fedfans.com/tags/JAVA/"/>
    
      <category term="MAVEN" scheme="http://blog.fedfans.com/tags/MAVEN/"/>
    
  </entry>
  
  <entry>
    <title>maven发布项目到私服-snapshot快照库和release发布库的区别和作用及maven常用命令</title>
    <link href="http://blog.fedfans.com//page/article/34/"/>
    <id>http://blog.fedfans.com//page/article/34/</id>
    <published>2018-05-14T12:06:36.000Z</published>
    <updated>2018-08-31T15:25:17.799Z</updated>
    
    <content type="html"><![CDATA[<p>在日常的工作中由于各种原因，会发生这样一种情况，某些项目并没有打包至mvnrepository。如果采用直接打包放到lib目录的方式进行处理，便对项目的管理带来一些不必要的麻烦。例如版本升级后需要重新打包并替换原有jar包等等一些额外的工作量和麻烦。为了避免这些不必要的麻烦，通常我们会通过Nexus搭建私有的仓库。下面着重介绍下怎么通过mvn命令将程序打包并发布到私有仓库Nexus中。</p><p>前提：</p><p>1.已成功安装maven</p><p>2.已成功安装Nexus（管理账号：admin，密码：admin123，搭建方式我写了一篇文章：<a href="https://www.520stone.com/page/article/35" target="_blank" rel="noopener">https://www.520stone.com/page/article/35</a>）</p><p>3.项目通过maven进行管理</p><p>maven安装目录下setting.xml中添加如下配置：</p><p>servers节点中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;releases&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;snapshots&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure><p>注意：如果非admin用户，需要在Nexus中对相应的账号设置密码</p><p>1.打开安全设置：<a href="http://localhost:8081/nexus/#security-users" target="_blank" rel="noopener">http://localhost:8081/nexus/#security-users</a></p><p>2.选择相应的用户–》右键–》reset password/set password –》进行密码设置</p><p>3.相应的仓库允许重复发布（Repository–》选择对应的仓库–》Configuration–》Deployment Policy下拉选项中选择“Allow Redeoploy”），如果不允许重复发布，重复发布时会出现401等异常情况。</p><p>项目下pom.xml中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 项目发布管理 --&gt;</span><br><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">  &lt;repository&gt;</span><br><span class="line">    &lt;id&gt;releases&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;User Project Release&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases/&lt;/url&gt;</span><br><span class="line">  &lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">  &lt;snapshotRepository&gt;</span><br><span class="line">    &lt;id&gt;snapshots&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;User Project SNAPSHOTS&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots/&lt;/url&gt;</span><br><span class="line">  &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>发布到私服</p><p>切换到项目根目录后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mvn clean deploy -X -Dmaven.test.skip=true</span><br><span class="line">```即可。如果发布成功会出现BUILD SUCCESS的字样。查看仓库http://127.0.0.1:8081/nexus/content/repositories/releases/已经包含了相应的包。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">如果想发布到snapshot仓库中，则需要在版本号后加上—SNAPSHOT（注意这里必须是大写）</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">&lt;groupId&gt;cc.mzone&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;m1&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></p><p>maven中snapshot快照库和release发布库的区别和作用</p><p>在使用maven过程中，我们在开发阶段经常性的会有很多公共库处于不稳定状态，随时需要修改并发布，可能一天就要发布一天，遇到bug时，甚至一天要发布N此。我们知道，maven的依赖管理是基于版本管理的，对于发布状态的artifact，如果版本号相同，即使我们内部的镜像服务器上的组件比本地新，maven也不会主动下载的。如果我们在开发阶段都是基于正式发布版本来做依赖版本，name遇到这个问题，就需要升级组件的版本号，可这样就明显不符合要求和实际情况了。但是，如果是基于快照版本，name问题就自然而然的解决了，而maven已经为我们准备好了这一切。</p><p>maven中的仓库分为两种，snapshot快照仓库和release发布仓库。snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库则是用来保存稳定的发布版本。定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上 -SNAPSHOT即可（注意这里必须是大写），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;cc.mzone&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;m1&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br></pre></td></tr></table></figure><p>maven2会根据模块的版本号（pom文件中的maven）中是否带有-SNAPSHOT来判断是否是快照版本还是正式版本。如果是快照版本，name在mvn deploy时会自动发布到快照版本库中，二使用快照版本的模块，在不更改版本的情况下，直接编译打包时，maven会自动从镜像仓库服务器上下载最新的快照版本。如果是正式发布版本，name在mvn deploy时会自动发布到正式版本库中，二使用正式版本的模块，在不更改版本的情况下，编译打包时如果已经存在该版本的模块则不会主动去镜像服务器上下载。</p><p>jar包发布到指定仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file -DgroupId=com.xy.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=E:\ojdbc14.jar -Durl=http://127.0.0.1:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty</span><br></pre></td></tr></table></figure><p>jar包发布到本地缓存仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>如果出现400，需要注意项目下的pom.xml文件和maven使用的setting.xml文件的配置是否一致。</li><li>如果出现401，需要检查maven使用的setting.xml中的账号和密码是否正确，相应的repository是否为ALLow redeploy</li><li>如果使用的intellij，eclipse或myeclipse需要注意ide中使用的setting.xml和maven命令行下的setting.xml是否一致；否则会出现许多莫名其妙的问题。</li></ol><p>原文地址：<a href="https://www.cnblogs.com/rwxwsblog/p/6029636.html" target="_blank" rel="noopener">https://www.cnblogs.com/rwxwsblog/p/6029636.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常的工作中由于各种原因，会发生这样一种情况，某些项目并没有打包至mvnrepository。如果采用直接打包放到lib目录的方式进行处理，便对项目的管理带来一些不必要的麻烦。例如版本升级后需要重新打包并替换原有jar包等等一些额外的工作量和麻烦。为了避免这些不必要的麻烦
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JAVA" scheme="http://blog.fedfans.com/tags/JAVA/"/>
    
      <category term="MAVEN" scheme="http://blog.fedfans.com/tags/MAVEN/"/>
    
  </entry>
  
</feed>
