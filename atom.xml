<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大米小米的博客</title>
  
  <subtitle>大米小米的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fedfans.com/"/>
  <updated>2019-05-08T06:31:28.765Z</updated>
  <id>http://blog.fedfans.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Influx时序数据库</title>
    <link href="http://blog.fedfans.com//page/article/influx%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.fedfans.com//page/article/influx时序数据库/</id>
    <published>2019-05-07T15:15:00.000Z</published>
    <updated>2019-05-08T06:31:28.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InfluxDB–时序数据库"><a href="#InfluxDB–时序数据库" class="headerlink" title="InfluxDB–时序数据库"></a>InfluxDB–时序数据库</h1><p><a name="xaMqU"></a></p><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>InfluxDB 是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。</p><p>类似的数据库有Elasticsearch、Graphite等。<br><strong>其主要特色功能</strong></p><ol><li>基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）</li><li>可度量性：你可以实时对大量数据进行计算</li><li>基于事件：它支持任意的事件数据</li></ol><p><strong>InfluxDB的主要特点</strong></p><ol><li>无结构（无模式）：可以是任意数量的列</li><li>可拓展的</li><li>支持min, max, sum, count, mean, median 等一系列函数，方便统计</li><li>原生的HTTP支持，内置HTTP API</li><li>强大的类SQL语法<br><a name="gCDFr"></a><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><a name="SySGA"></a><h4 id="1-1-1-与传统数据库的名词做比较"><a href="#1-1-1-与传统数据库的名词做比较" class="headerlink" title="1.1.1 与传统数据库的名词做比较"></a>1.1.1 与传统数据库的名词做比较</h4><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557135823326-4ba86192-d5dc-42c1-aaad-2cf86c04e575.png#align=left&amp;display=inline&amp;height=187&amp;name=image.png&amp;originHeight=187&amp;originWidth=654&amp;size=18068&amp;status=done&amp;width=654" alt="image.png"><br><a name="GGjEM"></a><h4 id="1-1-2-influx独有的概念"><a href="#1-1-2-influx独有的概念" class="headerlink" title="1.1.2 influx独有的概念"></a>1.1.2 influx独有的概念</h4><strong>Point</strong><br>Point由时间戳（time）、数据（field）、标签（tags）组成。<br>Point相当于传统数据库里的一行数据，如下表所示：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557135982313-63f36773-d447-4eda-88bf-f8a7366c0a36.png#align=left&amp;display=inline&amp;height=235&amp;name=image.png&amp;originHeight=235&amp;originWidth=627&amp;size=28123&amp;status=done&amp;width=627" alt="image.png"><br>influxdb 的时间精度是纳秒。这个跟prometheus不一样，prometheus是毫秒。这点也注意一下。<br>此处是重点，就是我们插入一条数据，使用的是:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert disk_free,xxx=1,yyy=2 value=3,age=18</span><br></pre></td></tr></table></figure><p>其中xxx和yyy是tags，而value和age是fields。<br>对于我们要检索的条件来说，我们要符合以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value,xxx from disk_free where xxx=1</span><br></pre></td></tr></table></figure><p>select的第一个要是fields的名字，第二个才能是对应tags的名字，而且后续条件那块要以tags，虽然后面where的条件也能对fields进行检索。<br>所以下面这种情况是不对的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select xxx from disk_free</span><br></pre></td></tr></table></figure><p>但是往往我们是根据对应的tag进行group化：<br>所以我们会用下面这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value,yyy from disk_free group by xxx</span><br></pre></td></tr></table></figure><p>这样我们如果使用到grafana就变成了两个折线图。<br><strong>series</strong><br>所有在数据库中的数据，都需要通过图表来展示，而这个series表示这个表里面的数据，可以在图表上画成几条线：通过tags排列组合算出来。<br>我们可以通过下面命令来查看某一个表的series</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show series from xxx</span><br></pre></td></tr></table></figure><p>或者查看整个database的series</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show series</span><br></pre></td></tr></table></figure><p><a name="h0hER"></a></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><a name="fk2Px"></a></p><h3 id="2-1-docker方式安装"><a href="#2-1-docker方式安装" class="headerlink" title="2.1 docker方式安装"></a>2.1 docker方式安装</h3><p><a href="https://hub.docker.com/_/influxdb" target="_blank" rel="noopener">https://hub.docker.com/_/influxdb</a><br>安装：<br>docker run -itd -p 8086:8086 influxdb<br>然后我们进入容器内部，如下:<br>docker exec -it ${containerId} bash<br>然后执行influx这个客户端，可以连接InfluxDB的server端进行操作。<br><a name="e5fBX"></a></p><h3 id="2-2-普通方式安装"><a href="#2-2-普通方式安装" class="headerlink" title="2.2 普通方式安装"></a>2.2 普通方式安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OS X (via Homebrew)</span><br><span class="line">brew update</span><br><span class="line">brew install influxdb</span><br><span class="line">MD5: 4f0aa76fee22cf4c18e2a0779ba4f462</span><br><span class="line"></span><br><span class="line">Ubuntu &amp; Debian (64-bit)</span><br><span class="line"></span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb_0.13.0_amd64.deb</span><br><span class="line">sudo dpkg -i influxdb_0.13.0_amd64.deb</span><br><span class="line">MD5: bcca4c91bbd8e7f60e4a8325be67a08a</span><br><span class="line"></span><br><span class="line">Ubuntu &amp; Debian (ARM)</span><br><span class="line"></span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb_0.13.0_armhf.deb</span><br><span class="line">sudo dpkg -i influxdb_0.13.0_armhf.deb</span><br><span class="line">MD5: b64ada82b6abf5d6382ed08dde1e8579</span><br><span class="line"></span><br><span class="line">RedHat &amp; CentOS (64-bit)</span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.x86_64.rpm</span><br><span class="line">sudo yum localinstall influxdb-0.13.0.x86_64.rpm</span><br><span class="line">MD5: 286b6c18aa4ef37225ea6605a729b61d</span><br><span class="line"></span><br><span class="line">RedHat &amp; CentOS (ARM)</span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0.armhf.rpm</span><br><span class="line">sudo yum localinstall influxdb-0.13.0.armhf.rpm</span><br><span class="line">MD5: 4cf99debb5315fbbb26166506807d965</span><br><span class="line"></span><br><span class="line">Standalone Binaries (64-bit)</span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0_linux_amd64.tar.gz</span><br><span class="line">tar xvfz influxdb-0.13.0_linux_amd64.tar.gz</span><br><span class="line">MD5: 187854536393c67f7793ada1c096da8e</span><br><span class="line"></span><br><span class="line">Standalone Binaries (ARM)</span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-0.13.0_linux_armhf.tar.gz</span><br><span class="line">tar xvfz influxdb-0.13.0_linux_armhf.tar.gz</span><br><span class="line"></span><br><span class="line">Docker Image</span><br><span class="line">docker pull influxdb</span><br></pre></td></tr></table></figure><p><a name="yhRXE"></a></p><h3 id="2-3-路径说明"><a href="#2-3-路径说明" class="headerlink" title="2.3 路径说明"></a>2.3 路径说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/influxdb/influxdb.conf 默认的配置文件</span><br><span class="line">/var/log/influxdb/influxd.log 日志文件</span><br><span class="line">/var/lib/influxdb/data 数据文件</span><br><span class="line">/usr/lib/influxdb/scripts 初始化脚本文件夹</span><br><span class="line">/usr/bin/influx 启动数据库</span><br></pre></td></tr></table></figure><p><a name="wLgHq"></a></p><h2 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h2><p><a name="Mnz9b"></a></p><h3 id="3-1-使用客户端influx"><a href="#3-1-使用客户端influx" class="headerlink" title="3.1 使用客户端influx"></a>3.1 使用客户端influx</h3><p>以docker的为例，我们前面已经安装了对应的influx，然后我们登录容器内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it $&#123;containerID&#125; bash</span><br></pre></td></tr></table></figure><p>然后进来后，我们执行influx –version可以查看对应的版本。<br>使用influx可以用这个客户端连接InfluxDB。<br><a name="mEe4t"></a></p><h3 id="3-2-数据库操作"><a href="#3-2-数据库操作" class="headerlink" title="3.2 数据库操作"></a>3.2 数据库操作</h3><p><a name="i4LpV"></a></p><h4 id="3-2-1-查看数据库"><a href="#3-2-1-查看数据库" class="headerlink" title="3.2.1 查看数据库"></a>3.2.1 查看数据库</h4><p>通过以下命令，我们可以查看一共有哪些databases。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases</span><br></pre></td></tr></table></figure></p><p><a name="Jrk4Z"></a></p><h4 id="3-2-2-新增数据库"><a href="#3-2-2-新增数据库" class="headerlink" title="3.2.2 新增数据库"></a>3.2.2 新增数据库</h4><p>我们通过create database操作来新建一个数据库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database test</span><br></pre></td></tr></table></figure></p><p><a name="6m3Ar"></a></p><h4 id="3-2-3-删除数据库"><a href="#3-2-3-删除数据库" class="headerlink" title="3.2.3 删除数据库"></a>3.2.3 删除数据库</h4><p>我们通过drop database操作来删除一个数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database test</span><br></pre></td></tr></table></figure><p><a name="B2oAN"></a></p><h4 id="3-2-4-使用数据库"><a href="#3-2-4-使用数据库" class="headerlink" title="3.2.4 使用数据库"></a>3.2.4 使用数据库</h4><p>我们可以通过use database来使用一个数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use database</span><br></pre></td></tr></table></figure><p><a name="7O8Jw"></a></p><h3 id="3-3-measurement操作"><a href="#3-3-measurement操作" class="headerlink" title="3.3 measurement操作"></a>3.3 measurement操作</h3><p><a name="WjyUZ"></a></p><h4 id="3-3-1-查看measurement"><a href="#3-3-1-查看measurement" class="headerlink" title="3.3.1 查看measurement"></a>3.3.1 查看measurement</h4><p>查看measurement其实相当于我们原来的查看有多少table一样。<br>执行的语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show measurements</span><br></pre></td></tr></table></figure><p><a name="vzUzt"></a></p><h4 id="3-3-2-新增measurement"><a href="#3-3-2-新增measurement" class="headerlink" title="3.3.2 新增measurement"></a>3.3.2 新增measurement</h4><p>没有显示的创建measurement的操作，我们只要插入了对应的数据就会创建对应的measurement</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert disk_free,hostname=server01 value=442221834240i</span><br></pre></td></tr></table></figure><p>最后的时间，不需要我们进行插入，这个是会自己生成的。<br><a name="pAvhv"></a></p><h4 id="3-3-3-删除measurement"><a href="#3-3-3-删除measurement" class="headerlink" title="3.3.3 删除measurement"></a>3.3.3 删除measurement</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop measurement disk_free</span><br></pre></td></tr></table></figure><p><a name="MiCeF"></a></p><h4 id="3-3-4-查询measurement的数据"><a href="#3-3-4-查询measurement的数据" class="headerlink" title="3.3.4 查询measurement的数据"></a>3.3.4 查询measurement的数据</h4><p>如下我们来查询disk_free这个measurement的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from disk_free</span><br></pre></td></tr></table></figure><p><a name="u8GEM"></a></p><h3 id="3-4-新增数据"><a href="#3-4-新增数据" class="headerlink" title="3.4 新增数据"></a>3.4 新增数据</h3><p><a name="WIrhU"></a></p><h4 id="3-4-1-新增数据"><a href="#3-4-1-新增数据" class="headerlink" title="3.4.1 新增数据"></a>3.4.1 新增数据</h4><p>如下，进行增加数据，如果measurement没有存在，则会创建这个measurement。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert disk_free,hostname=server01 value=442221834240i</span><br></pre></td></tr></table></figure></p><p>时序数据库的特点，决定没有删除和修改操作，所以这块并没有这两块的说明。<br>增加数据采用insert的方式，要注意的是 InfluxDB的insert中，表名与数据之间用逗号（,）分隔，tag和field之间用 空格分隔，多个tag或者多个field之间用逗号（,）分隔。<br>在上面那条语句中，disk_free是表名,hostname=server01是tag，属于索引，value=xx是field，这个可以随意写，随意定义。<br><a name="jcMPO"></a></p><h4 id="3-4-2-数据查询"><a href="#3-4-2-数据查询" class="headerlink" title="3.4.2 数据查询"></a>3.4.2 数据查询</h4><p>此处是重点，就是我们插入一条数据，使用的是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert disk_free,xxx=1,yyy=2 value=3,age=18</span><br></pre></td></tr></table></figure><p>其中xxx和yyy是tags，而value和age是fields。<br><strong>情况一：</strong><br>对于我们要检索的条件来说，我们要符合以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value,xxx from disk_free where xxx=1</span><br></pre></td></tr></table></figure><p>select的第一个要是fields的名字，第二个才能是对应tags的名字，而且后续条件那块要以tags，虽然后面where的条件也能对fields进行检索。<br>所以下面这种情况是不对的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select xxx from disk_free</span><br></pre></td></tr></table></figure><p><strong>情况二：</strong><br>但是往往我们是根据对应的tag进行group化：<br>所以我们会用下面这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value,yyy from disk_free group by xxx</span><br></pre></td></tr></table></figure><p>这样我们如果使用到grafana就变成了两个折线图。<br><strong>情况三：</strong><br>有时候group by xxx的时候，我们需要剔除掉某些不符合数据规范的数据，就可以用下面这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value from disk_free where xxx!=&apos;&apos; group by xxx</span><br></pre></td></tr></table></figure><p>这样就会把那些xxx为空的数据给剔除掉了，这样我们的折线图就去掉了某些干扰项。<br><strong>情况四：</strong><br>有时候，我们要制作饼图，这时候其实是按tag进行比例的划分，所以这时候的语句应该是如下的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(value) from disk_free group by xxx</span><br></pre></td></tr></table></figure><p>那这个时候，其实也能剔除掉对应的一些垃圾数据，类似于情况三的操作方式。<br><strong>情况五</strong><br>有时候我们只要展示xxx的某几种情况，不仅仅是情况三那种干扰某一个，比如我们需要包含几项。这时候我们会用正则进行匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value from disk_free where xxx =~ /^(111|222)$/ group by xxx</span><br></pre></td></tr></table></figure><p>这时候，111|222，我们可以通过grafana的变量来进行解决，所以上面的语句最终变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select value from disk_free where xxx =~ /^$xxx$/ group by xxx</span><br></pre></td></tr></table></figure><p>上面的$xxx会最终变成(111|222)，而/^$|则是一个正则。<br><a name="Zj5fq"></a></p><h3 id="3-5-连续查询"><a href="#3-5-连续查询" class="headerlink" title="3.5 连续查询"></a>3.5 连续查询</h3><p>InfluxDB的连续查询是在数据库中自动定时启动的一组语句，语句中必须包含SELECT关键词和GROUP BY time()关键词。<br>InfluxDB会将查询结果放到指定的数据表中。</p><p><strong>目的：</strong><br>使用连续查询是最优的降低采样率的方式，连续查询和存储策略搭配使用将会大大降低InfluxDB的系统占用量。<br>而且使用连续查询后，数据会存放到指定的数据库中，这样就为以后统计不同京都的数据提供了方便。<br><a name="JD49G"></a></p><h4 id="3-5-1-新增连续查询"><a href="#3-5-1-新增连续查询" class="headerlink" title="3.5.1 新增连续查询"></a>3.5.1 新增连续查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt; </span><br><span class="line">[RESAMPLE [EVERY &lt;interval&gt;] [FOR &lt;interval&gt;]] </span><br><span class="line">BEGIN SELECT &lt;<span class="keyword">function</span>&gt;(&lt;stuff&gt;)[,&lt;<span class="keyword">function</span>&gt;(&lt;stuff&gt;)] INTO &lt;different_measurement&gt; </span><br><span class="line">FROM &lt;current_measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;stuff&gt;] </span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONTINUOUS QUERY cq_30m ON telegraf BEGIN SELECT mean(used) INTO mem_used_30m FROM mem GROUP BY time(30m) END</span><br></pre></td></tr></table></figure><p><a name="21GVL"></a></p><h4 id="3-5-2-删除连续查询"><a href="#3-5-2-删除连续查询" class="headerlink" title="3.5.2 删除连续查询"></a>3.5.2 删除连续查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;</span><br></pre></td></tr></table></figure><p><a name="SVuLR"></a></p><h4 id="3-5-3-查询连续查询"><a href="#3-5-3-查询连续查询" class="headerlink" title="3.5.3 查询连续查询"></a>3.5.3 查询连续查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CONTINUOUS QUERIES</span><br></pre></td></tr></table></figure><p><a name="nijqw"></a></p><h3 id="3-6-InfluxDB常用函数使用"><a href="#3-6-InfluxDB常用函数使用" class="headerlink" title="3.6 InfluxDB常用函数使用"></a>3.6 InfluxDB常用函数使用</h3><p><a name="Av8sn"></a></p><h4 id="3-6-1-聚合类函数"><a href="#3-6-1-聚合类函数" class="headerlink" title="3.6.1 聚合类函数"></a>3.6.1 聚合类函数</h4><ul><li><strong>count()函数</strong></li></ul><p>返回一个（field）字段中的非空值的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT COUNT(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           count</span><br><span class="line">1970-01-01T00:00:00Z     15258</span><br></pre></td></tr></table></figure><p>如果想要指定时间:<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(water_level) FROM h2o_feet WHERE time &gt;= &apos;2015-08-18T00:00:00Z&apos; AND time &lt; &apos;2015-09-18T17:00:00Z&apos; GROUP BY time(4d)</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           count</span><br><span class="line">2015-08-17T00:00:00Z     1440</span><br><span class="line">2015-08-21T00:00:00Z     1920</span><br><span class="line">2015-08-25T00:00:00Z     1920</span><br><span class="line">2015-08-29T00:00:00Z     1920</span><br><span class="line">2015-09-02T00:00:00Z     1915</span><br><span class="line">2015-09-06T00:00:00Z     1920</span><br><span class="line">2015-09-10T00:00:00Z     1920</span><br><span class="line">2015-09-14T00:00:00Z     1920</span><br><span class="line">2015-09-18T00:00:00Z     335</span><br></pre></td></tr></table></figure><p>这样结果是按照时间划分的。</p><ul><li><strong>Distinct()函数</strong></li></ul><p>返回一个字段（field）的唯一值。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DISTINCT(&quot;level description&quot;) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           distinct</span><br><span class="line">1970-01-01T00:00:00Z     between 6 and 9 feet</span><br><span class="line">1970-01-01T00:00:00Z     below 3 feet</span><br><span class="line">1970-01-01T00:00:00Z     between 3 and 6 feet</span><br><span class="line">1970-01-01T00:00:00Z     at or greater than 9 feet</span><br></pre></td></tr></table></figure><p>这个例子显示level description这个字段共有四个值，然后将其显示了出来，时间为默认时间。</p><ul><li><strong>MEAN()函数</strong></li></ul><p>返回一个字段（field）中的值的算术平均值（平均值）。字段类型必须是长整型或float64。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MEAN(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEAN(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           mean</span><br><span class="line">1970-01-01T00:00:00Z     4.286791371454075</span><br></pre></td></tr></table></figure><p>说明water_level字段的平均值为<code>4.286791371454075</code></p><ul><li><strong>MEDIAN()函数</strong></li></ul><p>从单个字段（field）中的排序值返回中间值（中位数）。字段值的类型必须是长整型或float64格式。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MEDIAN(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MEDIAN(water_level) from h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           median</span><br><span class="line">1970-01-01T00:00:00Z     4.124</span><br></pre></td></tr></table></figure><p>说明表中water_level字段的中位数是4.124</p><ul><li><strong>SPREEAD()函数</strong></li></ul><p>返回字段的最小值和最大值之间的差值。数据的类型必须是长整型或float64。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SPREAD(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SPREAD(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            spread</span><br><span class="line">1970-01-01T00:00:00Z      10.574</span><br></pre></td></tr></table></figure><ul><li><strong>SUM()函数</strong></li></ul><p>返回一个字段中的所有值的和。字段的类型必须是长整型或float64。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT SUM(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           sum</span><br><span class="line">1970-01-01T00:00:00Z     67777.66900000002</span><br></pre></td></tr></table></figure><p>此语句计算出了 h2o_feet表中 所有 water_level 字段的和。<br><a name="ZyrXM"></a></p><h4 id="3-6-2-选择类函数"><a href="#3-6-2-选择类函数" class="headerlink" title="3.6.2 选择类函数"></a>3.6.2 选择类函数</h4><ul><li><strong>TOP()函数</strong></li></ul><p>作用：返回一个字段中最大的N个值，字段类型必须是长整型或float64类型。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT TOP(&quot;water_level&quot;,3) FROM &quot;h2o_feet&quot;</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">time                   top</span><br><span class="line">----                   ---</span><br><span class="line">2015-08-29T07:18:00Z   9.957</span><br><span class="line">2015-08-29T07:24:00Z   9.964</span><br><span class="line">2015-08-29T07:30:00Z   9.954</span><br></pre></td></tr></table></figure><p>这个示例返回表中water_level字段中最大的三个值。</p><ul><li><strong>BUTTOM()函数</strong></li></ul><p>作用：返回一个字段中最小的N个值。字段类型必须是长整型或float64类型。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_keys&gt;],&lt;N&gt;)[,&lt;tag_keys&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           bottom</span><br><span class="line">2015-08-29T14:30:00Z     -0.61</span><br><span class="line">2015-08-29T14:36:00Z     -0.591</span><br><span class="line">2015-08-30T15:18:00Z     -0.594</span><br></pre></td></tr></table></figure><p>这个例子返回表中water_level字段中最小的三个值。<br>也可将关联的tag放在一起查询，但如果tag值少于N的值，则返回的值的个数只会取tag中字段值少的那个。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT BOTTOM(water_level,location,3) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           bottom     location</span><br><span class="line">2015-08-29T10:36:00Z     -0.243     santa_monica</span><br><span class="line">2015-08-29T14:30:00Z     -0.61      coyote_creek</span><br></pre></td></tr></table></figure><p>语句取最小的三个值，然而结果只返回了2个值，因为location这个tag只有两个取值。</p><ul><li><strong>First()函数</strong></li></ul><p>作用：返回一个字段中最老的取值。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT FIRST(water_level) FROM h2o_feet WHERE location = &apos;santa_monica&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           first</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br></pre></td></tr></table></figure><p>这个语句返回了在location=’santa_monica’条件下，最旧的那个water_level的取值和时间。</p><ul><li><strong>Last()函数</strong></li></ul><p>作用：返回一个字段中最新的取值。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT LAST(water_level),location FROM h2o_feet WHERE time &gt;= &apos;2015-08-18T00:42:00Z&apos; and time &lt;= &apos;2015-08-18T00:54:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           last      location</span><br><span class="line">2015-08-18T00:54:00Z     6.982     coyote_creek</span><br></pre></td></tr></table></figure><ul><li><strong>MAX()函数</strong></li></ul><p>作用：返回一个字段中的最大值。该字段类型必须是长整型，float64，或布尔类型。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MAX(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           max       location</span><br><span class="line">2015-08-29T07:24:00Z     9.964     coyote_creek</span><br></pre></td></tr></table></figure><ul><li><strong>MIN 函数</strong></li></ul><p>作用：返回一个字段中的最小值。该字段类型必须是长整型，float64，或布尔类型。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT MIN(water_level),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                          min       location</span><br><span class="line">2015-08-29T14:30:00Z    -0.61     coyote_creek</span><br></pre></td></tr></table></figure><ul><li><strong>PRECENTILE()函数</strong></li></ul><p>作用：返回排序值排位为N的百分值。字段的类型必须是长整型或float64。<br>百分值是介于100到0之间的整数或浮点数，包括100。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;] FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT PERCENTILE(water_level,5),location FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                      percentile     location</span><br><span class="line">2015-08-28T12:06:00Z      1.122             santa_monica</span><br></pre></td></tr></table></figure><p>就是将water_level字段按照不同的location求百分比，然后取第五位数据。<br><a name="sUi2Z"></a></p><h4 id="3-6-2-变换类函数"><a href="#3-6-2-变换类函数" class="headerlink" title="3.6.2 变换类函数"></a>3.6.2 变换类函数</h4><ul><li><strong>DERIVATIVE()函数</strong></li></ul><p>作用：返回一个字段在一个series中的变化率。<br>InfluxDB会计算按照时间进行排序的字段值之间的<a href="https://www.linuxdaxue.com/tag/%e5%b7%ae%e5%bc%82/" target="_blank" rel="noopener">差异</a>，并将这些结果转化为单位变化率。其中，单位可以指定，默认为1s。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>其中unit取值可以为以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u --microseconds</span><br><span class="line">s --seconds</span><br><span class="line">m --minutes</span><br><span class="line">h --hours</span><br><span class="line">d --days</span><br><span class="line">w --weeks</span><br></pre></td></tr></table></figure><p>DERIVATIVE()函数还可以在GROUP BY time()的条件下与聚合函数嵌套使用，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) FROM &lt;measurement_name&gt; WHERE &lt;stuff&gt; GROUP BY time(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><p>示例：<br>假设location = santa_monica 条件下数据有以下几条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           water_level</span><br><span class="line">2015-08-18T00:00:00Z     2.064</span><br><span class="line">2015-08-18T00:06:00Z     2.116</span><br><span class="line">2015-08-18T00:12:00Z     2.028</span><br><span class="line">2015-08-18T00:18:00Z     2.126</span><br><span class="line">2015-08-18T00:24:00Z     2.041</span><br><span class="line">2015-08-18T00:30:00Z     2.051</span><br></pre></td></tr></table></figure><p>计算每一秒的变化率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level) FROM h2o_feet WHERE location = &apos;santa_monica&apos; LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.00014444444444444457</span><br><span class="line">2015-08-18T00:12:00Z     -0.00024444444444444465</span><br><span class="line">2015-08-18T00:18:00Z     0.0002722222222222218</span><br><span class="line">2015-08-18T00:24:00Z     -0.000236111111111111</span><br><span class="line">2015-08-18T00:30:00Z     2.777777777777842e-05</span><br></pre></td></tr></table></figure><p>第一行数据的计算公式为<code>(2.116 - 2.064) / (360s / 1s)</code><br>计算每六分钟的变化率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,6m) FROM h2o_feet WHERE location = &apos;santa_monica&apos; LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z     -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z     0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z     -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z     0.010000000000000231</span><br></pre></td></tr></table></figure><p>第一行数据的计算过程如下：<code>(2.116 - 2.064) / (6m / 6m)</code><br>计算每12分钟的变化率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(water_level,12m) FROM h2o_feet WHERE location = &apos;santa_monica&apos; LIMIT 5</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:06:00Z     0.10400000000000009</span><br><span class="line">2015-08-18T00:12:00Z     -0.17600000000000016</span><br><span class="line">2015-08-18T00:18:00Z     0.19599999999999973</span><br><span class="line">2015-08-18T00:24:00Z     -0.16999999999999993</span><br><span class="line">2015-08-18T00:30:00Z     0.020000000000000462</span><br></pre></td></tr></table></figure><p>第一行数据计算过程为：<code>(2.116 - 2.064 / (6m / 12m)</code><br>计算每12分钟最大值的变化率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DERIVATIVE(MAX(water_level)) FROM h2o_feet WHERE location = &apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; AND time &lt; &apos;2015-08-18T00:36:00Z&apos; GROUP BY time(12m)</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           derivative</span><br><span class="line">2015-08-18T00:12:00Z     0.009999999999999787</span><br><span class="line">2015-08-18T00:24:00Z     -0.07499999999999973</span><br></pre></td></tr></table></figure><p>这个函数功能非常多，也非常复杂，更多对于此功能的详细解释请看官网：<a href="https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v0.13/query_language/functions/#derivative</a></p><ul><li><strong>DIFFERENCE()函数</strong></li></ul><p>作用：返回一个字段中连续的时间值之间的<a href="https://www.linuxdaxue.com/tag/%e5%b7%ae%e5%bc%82/" target="_blank" rel="noopener">差异</a>。字段类型必须是长整型或float64。<br>最基本的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DIFFERENCE(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>与GROUP BY time()以及其他嵌套函数一起使用的语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DIFFERENCE(&lt;function&gt;(&lt;field_key&gt;)) FROM &lt;measurement_name&gt; WHERE &lt;stuff&gt; GROUP BY time(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>其中，函数可以包含以下几个：<br><code>COUNT()</code>, <code>MEAN()</code>, <code>MEDIAN()</code>,<code>SUM()</code>, <code>FIRST()</code>, <code>LAST()</code>, <code>MIN()</code>, <code>MAX()</code>, 和 <code>PERCENTILE()。</code><br>使用示例<br>例子中使用的源数据如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location=&apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:36:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><p>计算water_level间的差异：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT DIFFERENCE(water_level) FROM h2o_feet WHERE location=&apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:36:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            difference</span><br><span class="line">2015-08-18T00:06:00Z      0.052000000000000046</span><br><span class="line">2015-08-18T00:12:00Z      -0.08800000000000008</span><br><span class="line">2015-08-18T00:18:00Z      0.09799999999999986</span><br><span class="line">2015-08-18T00:24:00Z      -0.08499999999999996</span><br><span class="line">2015-08-18T00:30:00Z      0.010000000000000231</span><br><span class="line">2015-08-18T00:36:00Z      0.016000000000000014</span><br><span class="line">数据类型都为float类型。</span><br></pre></td></tr></table></figure><ul><li><strong>ELAPSED()函数</strong></li></ul><p>作用：返回一个字段在连续的时间间隔间的差异，间隔单位可选，默认为1纳秒。<br>单位可选项如下图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557153024523-ad0d6616-acce-405a-84ec-5ba91e0f02ee.png#align=left&amp;display=inline&amp;height=372&amp;name=image.png&amp;originHeight=744&amp;originWidth=468&amp;size=60540&amp;status=done&amp;width=234" alt="image.png"><br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ELAPSED(&lt;field_key&gt;, &lt;unit&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例：<br>计算h2o_feet字段在纳秒间隔下的差异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level) FROM h2o_feet WHERE location = &apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:24:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      360000000000</span><br><span class="line">2015-08-18T00:12:00Z      360000000000</span><br><span class="line">2015-08-18T00:18:00Z      360000000000</span><br><span class="line">2015-08-18T00:24:00Z      360000000000</span><br></pre></td></tr></table></figure></p><p>在一分钟间隔下的差异率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1m) FROM h2o_feet WHERE location = &apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:24:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      6</span><br><span class="line">2015-08-18T00:12:00Z      6</span><br><span class="line">2015-08-18T00:18:00Z      6</span><br><span class="line">2015-08-18T00:24:00Z      6</span><br></pre></td></tr></table></figure><p>注意：如果设置的时间间隔比字段数据间的时间间隔更大时，则函数会返回0，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT ELAPSED(water_level,1h) FROM h2o_feet WHERE location = &apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:24:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            elapsed</span><br><span class="line">2015-08-18T00:06:00Z      0</span><br><span class="line">2015-08-18T00:12:00Z      0</span><br><span class="line">2015-08-18T00:18:00Z      0</span><br><span class="line">2015-08-18T00:24:00Z      0</span><br></pre></td></tr></table></figure><ul><li><strong>MOVING_AVERAGE()函数</strong></li></ul><p>作用：返回一个连续字段值的移动平均值，字段类型必须是长整形或者float64类型。<br>语法：<br>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MOVING_AVERAGE(&lt;field_key&gt;,&lt;window&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>与其他函数和GROUP BY time()语句一起使用时的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MOVING_AVERAGE(&lt;function&gt;(&lt;field_key&gt;),&lt;window&gt;) FROM &lt;measurement_name&gt; WHERE &lt;stuff&gt; GROUP BY time(&lt;time_interval&gt;)</span><br></pre></td></tr></table></figure><p>此函数可以和以下函数一起使用：<br>COUNT(), MEAN(),MEDIAN(), SUM(), FIRST(), LAST(), MIN(), MAX(), and PERCENTILE().<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT water_level FROM h2o_feet WHERE location = &apos;santa_monica&apos; AND time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt;= &apos;2015-08-18T00:36:00Z&apos;</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                            water_level</span><br><span class="line">2015-08-18T00:00:00Z      2.064</span><br><span class="line">2015-08-18T00:06:00Z      2.116</span><br><span class="line">2015-08-18T00:12:00Z      2.028</span><br><span class="line">2015-08-18T00:18:00Z      2.126</span><br><span class="line">2015-08-18T00:24:00Z      2.041</span><br><span class="line">2015-08-18T00:30:00Z      2.051</span><br><span class="line">2015-08-18T00:36:00Z      2.067</span><br></pre></td></tr></table></figure><ul><li><strong>NON_NEGATIVE_DERIVATIVE()函数</strong></li></ul><p>作用：返回在一个series中的一个字段中值的变化的非负速率。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NON_NEGATIVE_DERIVATIVE(&lt;field_key&gt;, [&lt;unit&gt;]) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>其中unit取值可以为以下几个：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557153263507-1161b8ba-ea9a-4c34-a8bd-940beda416e3.png#align=left&amp;display=inline&amp;height=186&amp;name=image.png&amp;originHeight=372&amp;originWidth=492&amp;size=50988&amp;status=done&amp;width=246" alt="image.png"><br>与聚合函数一块使用的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NON_NEGATIVE_DERIVATIVE(AGGREGATION_FUNCTION(&lt;field_key&gt;),[&lt;unit&gt;]) FROM &lt;measurement_name&gt; WHERE &lt;stuff&gt; GROUP BY time(&lt;aggregation_interval&gt;)</span><br></pre></td></tr></table></figure><ul><li><strong>STDDEV()函数</strong></li></ul><p>作用：返回一个字段中的值的标准偏差。值的类型必须是长整型或float64类型。<br>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT STDDEV(&lt;field_key&gt;) FROM &lt;measurement_name&gt; [WHERE &lt;stuff&gt;] [GROUP BY &lt;stuff&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet</span><br><span class="line">name: h2o_feet</span><br><span class="line">--------------</span><br><span class="line">time                           stddev</span><br><span class="line">1970-01-01T00:00:00Z     2.279144584196145</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT STDDEV(water_level) FROM h2o_feet WHERE time &gt;= &apos;2015-08-18T00:00:00Z&apos; and time &lt; &apos;2015-09-18T12:06:00Z&apos; GROUP BY time(1w), location</span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = coyote_creek</span><br><span class="line">time                           stddev</span><br><span class="line">----                           ------</span><br><span class="line">2015-08-13T00:00:00Z     2.2437263080193985</span><br><span class="line">2015-08-20T00:00:00Z     2.121276150144719</span><br><span class="line">2015-08-27T00:00:00Z     3.0416122170786215</span><br><span class="line">2015-09-03T00:00:00Z     2.5348065025435207</span><br><span class="line">2015-09-10T00:00:00Z     2.584003954882673</span><br><span class="line">2015-09-17T00:00:00Z     2.2587514836274414</span><br><span class="line"></span><br><span class="line">name: h2o_feet</span><br><span class="line">tags: location = santa_monica</span><br><span class="line">time                           stddev</span><br><span class="line">----                           ------</span><br><span class="line">2015-08-13T00:00:00Z     1.11156344587553</span><br><span class="line">2015-08-20T00:00:00Z     1.0909849279082366</span><br><span class="line">2015-08-27T00:00:00Z     1.9870116180096962</span><br><span class="line">2015-09-03T00:00:00Z     1.3516778450902067</span><br><span class="line">2015-09-10T00:00:00Z     1.4960573811500588</span><br><span class="line">2015-09-17T00:00:00Z     1.075701669442093</span><br></pre></td></tr></table></figure><p><a name="hDCT3"></a></p><h2 id="四、API库操作"><a href="#四、API库操作" class="headerlink" title="四、API库操作"></a>四、API库操作</h2><p><a name="tMJrZ"></a></p><h3 id="4-1-安装node的API包"><a href="#4-1-安装node的API包" class="headerlink" title="4.1 安装node的API包"></a>4.1 安装node的API包</h3><p>通过influx包，操作InfluxDB。<br>地址：<a href="https://www.npmjs.com/package/influx" target="_blank" rel="noopener">https://www.npmjs.com/package/influx</a><br><a name="P5UVO"></a></p><h3 id="4-2-新增database"><a href="#4-2-新增database" class="headerlink" title="4.2 新增database"></a>4.2 新增database</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line"><span class="keyword">await</span> influx.createDatabase(<span class="string">'helloworld'</span>);</span><br></pre></td></tr></table></figure><p><a name="MlISg"></a></p><h3 id="4-3-删除database"><a href="#4-3-删除database" class="headerlink" title="4.3 删除database"></a>4.3 删除database</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line"><span class="keyword">await</span> influx.dropDatabase(<span class="string">'helloworld'</span>);</span><br></pre></td></tr></table></figure><p><a name="gNP8B"></a></p><h3 id="4-4-判断是否存在database"><a href="#4-4-判断是否存在database" class="headerlink" title="4.4 判断是否存在database"></a>4.4 判断是否存在database</h3><p>下面的代码，判断如果不存在则取创建这个database<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">await</span> influx.getDatabaseNames()).filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> value === <span class="string">'helloworld'</span>;</span><br><span class="line">&#125;).length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">await</span> influx.createDatabase(<span class="string">'helloworld'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a name="0XF6f"></a></p><h3 id="4-5-插入measurement数据"><a href="#4-5-插入measurement数据" class="headerlink" title="4.5 插入measurement数据"></a>4.5 插入measurement数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> influx2 = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">database</span>: <span class="string">'helloworld'</span>&#125;);</span><br><span class="line"><span class="keyword">await</span> influx2.writeMeasurement(<span class="string">'hello'</span>, [&#123;</span><br><span class="line">  tags: &#123;<span class="attr">host</span>: <span class="string">'box1.example.com'</span>&#125;,</span><br><span class="line">  fields: &#123;<span class="attr">cpu</span>: <span class="number">123</span>, <span class="attr">mem</span>: <span class="number">234</span>&#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><p><a name="BTpKH"></a></p><h3 id="4-6-查询measurement数据"><a href="#4-6-查询measurement数据" class="headerlink" title="4.6 查询measurement数据"></a>4.6 查询measurement数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rows = <span class="keyword">await</span> influx2.query(<span class="string">`select * from response_times where host=<span class="subst">$&#123;Influx.<span class="built_in">escape</span>.stringLit(os.hostname())&#125;</span> order by time desc limit 10`</span>)</span><br><span class="line">rows.forEach(<span class="function"><span class="params">row</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`A request to <span class="subst">$&#123;row.cpu&#125;</span> took <span class="subst">$&#123;row.mem&#125;</span>ms`</span>))</span><br></pre></td></tr></table></figure><p><a name="rkSWO"></a></p><h2 id="五、数据备份和恢复"><a href="#五、数据备份和恢复" class="headerlink" title="五、数据备份和恢复"></a>五、数据备份和恢复</h2><p>InfluxDB提供了数据的备份和恢复方法，在实际工作中，可以通过这些方法来实现数据的高可用。<br><a name="fL7ql"></a></p><h3 id="5-1-数据备份"><a href="#5-1-数据备份" class="headerlink" title="5.1 数据备份"></a>5.1 数据备份</h3><p><a name="ynxzh"></a></p><h4 id="5-1-1-备份元数据"><a href="#5-1-1-备份元数据" class="headerlink" title="5.1.1 备份元数据"></a>5.1.1 备份元数据</h4><p>influxDB本地备份元数据的语法如下，这只会备份InfluxDB的的internal库数据，包含那些最基本的系统信息、用户信息等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup &lt;path-to-backup&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">influxd backup /tmp/backup</span><br><span class="line">2016/02/01 17:15:03 backing up metastore to /tmp/backup/meta.00</span><br><span class="line">2016/02/01 17:15:03 backup complete</span><br></pre></td></tr></table></figure><p><a name="K7ui4"></a></p><h4 id="5-1-2-备份数据库"><a href="#5-1-2-备份数据库" class="headerlink" title="5.1.2 备份数据库"></a>5.1.2 备份数据库</h4><p>可以通过 -database 参数来指定备份的数据库。<br>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -database &lt;mydatabase&gt; &lt;path-to-backup&gt;</span><br></pre></td></tr></table></figure><p>其他可选的参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retention &lt;retention policy name&gt;</span><br><span class="line">-shard &lt;shard ID&gt;</span><br><span class="line">-since &lt;date&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -database telegraf -retention autogen -since 2016-02-01T00:00:00Z /tmp/backup</span><br><span class="line">2016/02/01 18:02:36 backing up rp=default since 2016-02-01 00:00:00 +0000 UTC</span><br><span class="line">2016/02/01 18:02:36 backing up metastore to /tmp/backup/meta.01</span><br><span class="line">2016/02/01 18:02:36 backing up db=telegraf rp=default shard=2 to /tmp/backup/telegraf.default.00002.01 since 2016-02-01 00:00:00 +0000 UTC</span><br><span class="line">2016/02/01 18:02:36 backup complete</span><br></pre></td></tr></table></figure><p><a name="iCZR2"></a></p><h4 id="5-1-4-远程备份"><a href="#5-1-4-远程备份" class="headerlink" title="5.1.4 远程备份"></a>5.1.4 远程备份</h4><p>InfluxDB可以使用 -host 参数实现数据的远程备份，端口一般是8088</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd backup -database mydatabase -host 10.0.0.1:8088 /tmp/mysnapshot</span><br></pre></td></tr></table></figure><p><a name="J7Mcz"></a></p><h3 id="5-2-数据恢复"><a href="#5-2-数据恢复" class="headerlink" title="5.2 数据恢复"></a>5.2 数据恢复</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd restore [ -metadir | -datadir ] &lt;path-to-meta-or-data-directory&gt; &lt;path-to-backup&gt;</span><br></pre></td></tr></table></figure><p>必要参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-metadir &lt;path-to-meta-directory&gt;</span><br><span class="line">或</span><br><span class="line">-datadir &lt;path-to-data-directory&gt;</span><br></pre></td></tr></table></figure><p>可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-database &lt;database&gt;</span><br><span class="line">-retention &lt;retention policy&gt;</span><br><span class="line">-shard &lt;shard id&gt;</span><br></pre></td></tr></table></figure><p>示例，恢复数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ influxd restore -database telegraf -datadir /var/lib/influxdb/data /tmp/backup                                                                         </span><br><span class="line">Restoring from backup /tmp/backup/telegraf.*</span><br><span class="line">unpacking /var/lib/influxdb/data/telegraf/default/2/000000004-000000003.tsm</span><br><span class="line">unpacking /var/lib/influxdb/data/telegraf/default/2/000000005-000000001.tsm</span><br></pre></td></tr></table></figure><p><a name="2FsTi"></a></p><h2 id="五、原理篇"><a href="#五、原理篇" class="headerlink" title="五、原理篇"></a>五、原理篇</h2><p>这块研究的时候，可以看一下网易大神：范欣欣的文章<br><a href="http://hbasefly.com/category/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">http://hbasefly.com/category/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</a><br><a name="7iGlp"></a></p><h2 id="六、账号体系"><a href="#六、账号体系" class="headerlink" title="六、账号体系"></a>六、账号体系</h2><p><a name="jdzBF"></a></p><h3 id="6-1-查看账号"><a href="#6-1-查看账号" class="headerlink" title="6.1 查看账号"></a>6.1 查看账号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show users</span><br></pre></td></tr></table></figure><p><a name="PrK7D"></a></p><h3 id="6-2-新建账号"><a href="#6-2-新建账号" class="headerlink" title="6.2 新建账号"></a>6.2 新建账号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user “username” with password ‘password’</span><br></pre></td></tr></table></figure><p>此处注意，password必须用单引号引起来。<br><a name="a3jJq"></a></p><h3 id="6-3-新建含有权限的账号"><a href="#6-3-新建含有权限的账号" class="headerlink" title="6.3 新建含有权限的账号"></a>6.3 新建含有权限的账号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user “username” with password ‘password’ with all privileges</span><br></pre></td></tr></table></figure><p><a name="QhrqL"></a></p><h3 id="6-4-修改用户密码"><a href="#6-4-修改用户密码" class="headerlink" title="6.4 修改用户密码"></a>6.4 修改用户密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR admin =’influx@gpscloud’</span><br></pre></td></tr></table></figure><p><a name="mIyRQ"></a></p><h3 id="6-5-删除用户"><a href="#6-5-删除用户" class="headerlink" title="6.5 删除用户"></a>6.5 删除用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user ‘username’ 删除用户</span><br></pre></td></tr></table></figure><p><a name="mI20p"></a></p><h2 id="七、常用问题篇"><a href="#七、常用问题篇" class="headerlink" title="七、常用问题篇"></a>七、常用问题篇</h2><p><a name="ymCTJ"></a></p><h3 id="7-1-集群搭建方式"><a href="#7-1-集群搭建方式" class="headerlink" title="7.1 集群搭建方式"></a>7.1 集群搭建方式</h3><p>官方的集群方案是收费的，但是由于influxDB是开源的，所以应该会有人做出来开源集群模式。</p><p><a name="R3JaQ"></a></p><h3 id="7-2-UI-无法连接的问题"><a href="#7-2-UI-无法连接的问题" class="headerlink" title="7.2 UI 无法连接的问题"></a>7.2 UI 无法连接的问题</h3><p>InfluxDB在0.13版本以后，就默认关闭了web管理页面。如果是0.13版本到1.1版本之间的版本，我们可以通过修改配置文件：<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/187105/1557153763170-0db6923e-1638-45e1-98e4-3030f36f453c.jpeg#align=left&amp;display=inline&amp;height=274&amp;originHeight=274&amp;originWidth=614&amp;size=0&amp;status=done&amp;width=614" alt=""><br>将enabled改为true并把注释删除。然后https看应用场景。<br>但是如果使用的是1.1版本之后的，则没有web管理界面了。<br>版本如何查看，我们可以使用客户端软件 influx –version就能看到。</p><p><a name="M18mb"></a></p><h3 id="7-3-单机InfluxDB能支撑多大"><a href="#7-3-单机InfluxDB能支撑多大" class="headerlink" title="7.3 单机InfluxDB能支撑多大"></a>7.3 单机InfluxDB能支撑多大</h3><p>我们查看API，他可以批量插入和非批量插入。以下测试在自己电脑上进行测试，得出结论基本是数字的差别，规律是相同的。</p><p><a name="eAgLh"></a></p><h4 id="7-3-1-批量插入："><a href="#7-3-1-批量插入：" class="headerlink" title="7.3.1 批量插入："></a>7.3.1 批量插入：</h4><p>以下数据测试方法: 10次以下结果的平均。平均看到的情况，在5万附近，并不会随着数据量的增长，而出现明显的增长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1次1万条, 花费了151ms, 平均下来一秒插入66050条数据</span><br><span class="line">1次2万条, 花费了342ms, 平均下来一秒插入58462条数据</span><br><span class="line">1次3万条, 花费了652ms, 平均下来一秒插入46005条数据</span><br><span class="line">1次4万条, 花费了766ms, 平均下来一秒插入52192条数据</span><br><span class="line">1次5万条, 花费了882ms, 平均下来一秒插入56637条数据</span><br><span class="line">1次6万条, 花费了1185ms, 平均下来一秒插入50603条数据</span><br><span class="line">1次7万条, 花费了1277ms, 平均下来一秒插入54807条数据</span><br><span class="line">1次8万条, 花费了1472ms, 平均下来一秒插入54336条数据</span><br><span class="line">1次9万条, 花费了1597ms, 平均下来一秒插入56330条数据</span><br><span class="line">1次10万条, 花费了1764ms, 平均下来一秒插入56663条数据</span><br><span class="line">1次11万条, 花费了2181ms, 平均下来一秒插入50421条数据</span><br><span class="line">1次12万条, 花费了2494ms, 平均下来一秒插入48107条数据</span><br><span class="line">1次13万条, 花费了2642ms, 平均下来一秒插入49197条数据</span><br><span class="line">1次14万条, 花费了2825ms, 平均下来一秒插入49557条数据</span><br><span class="line">1次15万条以上，测试过程中会报错，所以单次插入量不能太大。先会出现Internal Server Error的情况</span><br><span class="line">再往上增长，则会出现Request Entity Too Large.</span><br></pre></td></tr></table></figure><p>所以批量插入的情况来看，量能承受比较大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Influx = <span class="built_in">require</span>(<span class="string">'influx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">await</span> influx.getDatabaseNames()).filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value === <span class="string">'helloworld'</span>;</span><br><span class="line">    &#125;).length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> influx.dropDatabase(<span class="string">'helloworld'</span>)</span><br><span class="line">        <span class="keyword">await</span> influx.createDatabase(<span class="string">'helloworld'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> influx2 = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">database</span>: <span class="string">'helloworld'</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num * <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        data.push(&#123;</span><br><span class="line">            measurement: <span class="string">'hello'</span>,</span><br><span class="line">            tags: &#123;<span class="attr">host</span>: <span class="string">'box'</span> + i + <span class="string">'.example.com'</span>&#125;,</span><br><span class="line">            fields: &#123;<span class="attr">cpu</span>: <span class="number">123</span>, <span class="attr">mem</span>: <span class="number">234</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> influx2.writePoints(data);</span><br><span class="line">    <span class="keyword">const</span> useTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime;</span><br><span class="line">    <span class="keyword">if</span>(result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.num;</span><br><span class="line">    &#125;).filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value === num;</span><br><span class="line">    &#125;).length === <span class="number">0</span>)&#123;</span><br><span class="line">        result.push(&#123;</span><br><span class="line">            num: num,</span><br><span class="line">            useTime: [useTime]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.num === num;</span><br><span class="line">        &#125;)[<span class="number">0</span>].useTime.push(useTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">boostrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">await</span> write(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> useTime = item.useTime.reduce(<span class="function">(<span class="params">previous, current</span>)=&gt;</span>&#123;<span class="keyword">return</span> previous + current&#125;, <span class="number">0</span>)/item.useTime.length</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1次'</span> + item.num + <span class="string">'万条, 花费了'</span> + <span class="built_in">parseInt</span>(useTime) + <span class="string">"ms, 平均下来一秒插入"</span> + <span class="built_in">parseInt</span>(item.num * <span class="number">10000</span>/useTime*<span class="number">1000</span>) +<span class="string">"条数据"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">boostrap();</span><br></pre></td></tr></table></figure><p><a name="1bvIk"></a></p><h4 id="7-3-2-非批量插入"><a href="#7-3-2-非批量插入" class="headerlink" title="7.3.2 非批量插入"></a>7.3.2 非批量插入</h4><p>非批量操作，简称，每次插入一条数据。那这种肯定是会比较慢的。应用场景：比如应用连接了对应的influxDB，然后来一条数据插入一条。<br>以下是测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Influx = <span class="built_in">require</span>(<span class="string">'influx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">await</span> influx.getDatabaseNames()).filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value === <span class="string">'helloworld'</span>;</span><br><span class="line">    &#125;).length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> influx.dropDatabase(<span class="string">'helloworld'</span>)</span><br><span class="line">        <span class="keyword">await</span> influx.createDatabase(<span class="string">'helloworld'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> influx2 = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">database</span>: <span class="string">'helloworld'</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num * <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">await</span> influx2.writePoints([&#123;</span><br><span class="line">            measurement: <span class="string">'hello'</span>,</span><br><span class="line">            tags: &#123;<span class="attr">host</span>: <span class="string">'box'</span> + i + <span class="string">'.example.com'</span>&#125;,</span><br><span class="line">            fields: &#123;<span class="attr">cpu</span>: <span class="number">123</span>, <span class="attr">mem</span>: <span class="number">234</span>&#125;</span><br><span class="line">        &#125;]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> useTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime;</span><br><span class="line">    <span class="keyword">if</span>(result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.num;</span><br><span class="line">    &#125;).filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value === num;</span><br><span class="line">    &#125;).length === <span class="number">0</span>)&#123;</span><br><span class="line">        result.push(&#123;</span><br><span class="line">            num: num,</span><br><span class="line">            useTime: [useTime]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.num === num;</span><br><span class="line">        &#125;)[<span class="number">0</span>].useTime.push(useTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">boostrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">await</span> write(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> useTime = item.useTime.reduce(<span class="function">(<span class="params">previous, current</span>)=&gt;</span>&#123;<span class="keyword">return</span> previous + current&#125;, <span class="number">0</span>)/item.useTime.length</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1次'</span> + item.num*<span class="number">100</span> + <span class="string">'条, 花费了'</span> + <span class="built_in">parseInt</span>(useTime) + <span class="string">"ms, 平均下来一秒插入"</span> + <span class="built_in">parseInt</span>(item.num * <span class="number">100</span>/useTime*<span class="number">1000</span>) +<span class="string">"条数据"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">boostrap();</span><br></pre></td></tr></table></figure><p>数据结果：<br>测试结果，均是10次的平均值，还是比较准确反映了当前的性能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">100条, 花费了771ms, 平均下来一秒插入129条数据</span><br><span class="line">200条, 花费了1692ms, 平均下来一秒插入118条数据</span><br><span class="line">300条, 花费了2319ms, 平均下来一秒插入129条数据</span><br><span class="line">400条, 花费了2994ms, 平均下来一秒插入133条数据</span><br><span class="line">500条, 花费了3776ms, 平均下来一秒插入132条数据</span><br><span class="line">600条, 花费了4788ms, 平均下来一秒插入125条数据</span><br><span class="line">700条, 花费了5250ms, 平均下来一秒插入133条数据</span><br><span class="line">800条, 花费了5973ms, 平均下来一秒插入133条数据</span><br><span class="line">900条, 花费了6765ms, 平均下来一秒插入133条数据</span><br><span class="line">1000条, 花费了7491ms, 平均下来一秒插入133条数据</span><br><span class="line">1100条, 花费了8161ms, 平均下来一秒插入134条数据</span><br><span class="line">1200条, 花费了8733ms, 平均下来一秒插入137条数据</span><br><span class="line">1300条, 花费了9492ms, 平均下来一秒插入136条数据</span><br><span class="line">1400条, 花费了10373ms, 平均下来一秒插入134条数据</span><br></pre></td></tr></table></figure></p><p><a name="QJU9u"></a></p><h4 id="7-3-3-存储数据"><a href="#7-3-3-存储数据" class="headerlink" title="7.3.3 存储数据"></a>7.3.3 存储数据</h4><p>我们通过查看du -sh /var/lib/influxdb/data/helloworld，最后这个helloworld也就是对应database的名字。<br>数据情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1万条：504k</span><br><span class="line">2万条：956k</span><br><span class="line">3万条：1.4M</span><br><span class="line">4万条：1.9M</span><br><span class="line">5万条：2.3M</span><br><span class="line">6万条：2.7M</span><br><span class="line">7万条：3.2M</span><br><span class="line">8万条：3.6M</span><br><span class="line">9万条：4.1M</span><br><span class="line">10万条：4.5M</span><br><span class="line">11万条：4.9M</span><br><span class="line">12万条：5.4M</span><br><span class="line">13万条：5.8M</span><br><span class="line">14万条：6.3M</span><br><span class="line">15万条：6.7M</span><br></pre></td></tr></table></figure><p>这个数据大小，一个point数据的大小有关，比如当前一条数据：<br>其中host字段是tag，而cpu和mem是fields，所以关于数据量的估量，也是监控系统需要考虑的问题。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/187105/1557235302652-ee68b662-41ef-4aed-b22f-66a077d4fe72.png#align=left&amp;display=inline&amp;height=81&amp;name=image.png&amp;originHeight=81&amp;originWidth=380&amp;size=7928&amp;status=done&amp;width=380" alt="image.png"><br><a name="D9N0N"></a></p><h4 id="7-3-4-读的性能"><a href="#7-3-4-读的性能" class="headerlink" title="7.3.4 读的性能"></a>7.3.4 读的性能</h4><p>为什么要测试读的性能，我们会在Grafana上面配置很多图表，如果数据源是InfluxDB的话，一个图表意味着1~N次请求，那么一个dashboard其实是有好多请求。这个时候，如果有很多个人在看自己的Dashboard的话，那么对于InfluxDB的压力还是比较大的。<br>测试代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Influx = <span class="built_in">require</span>(<span class="string">'influx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> influx = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">await</span> influx.getDatabaseNames()).filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value === <span class="string">'helloworld'</span>;</span><br><span class="line">    &#125;).length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> influx.dropDatabase(<span class="string">'helloworld'</span>)</span><br><span class="line">        <span class="keyword">await</span> influx.createDatabase(<span class="string">'helloworld'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num * <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        data.push(&#123;</span><br><span class="line">            measurement: <span class="string">'hello'</span>,</span><br><span class="line">            tags: &#123;<span class="attr">host</span>: <span class="string">'box'</span> + i + <span class="string">'.example.com'</span>&#125;,</span><br><span class="line">            fields: &#123;<span class="attr">cpu</span>: <span class="number">123</span>, <span class="attr">mem</span>: <span class="number">234</span>&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> influx2.writePoints(data);</span><br><span class="line">    <span class="keyword">const</span> useTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime;</span><br><span class="line">    <span class="keyword">if</span>(result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item.num;</span><br><span class="line">    &#125;).filter(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value === num;</span><br><span class="line">    &#125;).length === <span class="number">0</span>)&#123;</span><br><span class="line">        result.push(&#123;</span><br><span class="line">            num: num,</span><br><span class="line">            useTime: [useTime]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.num === num;</span><br><span class="line">        &#125;)[<span class="number">0</span>].useTime.push(useTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">boostrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> influx2 = <span class="keyword">new</span> Influx.InfluxDB(&#123;<span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">database</span>: <span class="string">'helloworld'</span>&#125;);</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="number">15</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> z = <span class="number">0</span>; z &lt; <span class="number">1</span>*j; z++)&#123;</span><br><span class="line">                <span class="keyword">await</span> influx2.query(<span class="string">`select count(mem) from hello limit 10000`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            <span class="keyword">if</span>(result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> item.num;</span><br><span class="line">            &#125;).filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value === <span class="number">1</span> *j</span><br><span class="line">            &#125;).length === <span class="number">0</span>)&#123;</span><br><span class="line">                result.push(&#123;</span><br><span class="line">                    num: <span class="number">1</span>*j,</span><br><span class="line">                    useTime: [endTime-startTime]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.filter(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value.num === <span class="number">1</span>*j</span><br><span class="line">                &#125;)[<span class="number">0</span>].useTime.push(endTime-startTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"====&gt;"</span> + j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'一共'</span> + item.num + <span class="string">"次查询, 平均花费"</span> + <span class="built_in">parseInt</span>(item.useTime.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b, <span class="number">0</span>)/item.num/item.useTime.length) + <span class="string">"ms"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">boostrap();</span><br></pre></td></tr></table></figure></p><p>结论数据：<br>在15万的数据表中，进行查询count的操作。select count(mem) from hello limit 10000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一共1次查询, 平均花费200ms</span><br><span class="line">一共2次查询, 平均花费315ms</span><br><span class="line">一共3次查询, 平均花费171ms</span><br><span class="line">一共4次查询, 平均花费143ms</span><br><span class="line">一共5次查询, 平均花费169ms</span><br><span class="line">一共6次查询, 平均花费139ms</span><br><span class="line">一共7次查询, 平均花费155ms</span><br><span class="line">一共8次查询, 平均花费166ms</span><br><span class="line">一共9次查询, 平均花费147ms</span><br><span class="line">一共10次查询, 平均花费188ms</span><br><span class="line">一共11次查询, 平均花费162ms</span><br><span class="line">一共12次查询, 平均花费246ms</span><br><span class="line">一共13次查询, 平均花费141ms</span><br><span class="line">一共14次查询, 平均花费160ms</span><br></pre></td></tr></table></figure></p><p>然后得出上面的结论，说明当数据量比较大的时候，查询一次操作，需要花费的时间还是蛮大的。<br>所以这块如何提升性能，还是比较重要的。不然图表多了，那必然响应不过来了。<br>15w数据量是多大的数据量：假设我们5秒一条数据，1天的量：12 <em> 60 </em> 24=17280，差不多一天2万的量，也就是有一周的数据量。<br>当我们在一个一周数据量的数据里面，捞我们想要的数据，假如一个grafana的dashboard是10个图表，假设10个接口，那按照上面的算法，毛估估还是要花费比较长时间的。<br>然后用ab测试了一下性能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 20 -c 5 -H &quot;Cookie: email=hzjinbing%40163.com; username=jinbing; grafana_session=af2db0101608c095d7ea7b55e7bc0ddb&quot; http://127.0.0.1:32768/api/datasources/proxy/6/query\?db\=helloworld\&amp;q\=SELECT%20count\(%22mem%22\)%20FROM%20%22hello%22%20WHERE%20time%20%3E%3D%20now\(\)%20-%206h%20GROUP%20BY%20time\(20s\)%20fill\(null\)\&amp;epoch\=ms</span><br></pre></td></tr></table></figure><p>此处我拿了一个grafana图表的接口进行压测。<br>效果：大概每秒只能处理两个请求，说明，真实的时候，当量大了之后，确实这个反应应该如何处理，否则grafana去InfluxDB数据源去展示的时候，人多了完全不能看呀。<br><a name="oe4XK"></a></p><h4 id="7-3-5-结论"><a href="#7-3-5-结论" class="headerlink" title="7.3.5 结论"></a>7.3.5 结论</h4><p>如果在单机的情况下，我们可以做对应的数据聚合层，然后将数据聚合然后再存储到对应的influxDB。</p><ol><li>减少了跟InfluxDB的连接数量</li><li>单次插入一条的性能，要远远小于单次批量插入多条的性能。</li></ol><p>这块，influxdb-relay 是官方提供的高可用方案，但是它只提供简单的写入功能。初期使用问题不大，因为对于写的问题暴露的不明显，但是随着业务方的增长，对于读这块的请求比较大的时候，又会引起InfluxDB的性能瓶颈。</p><h2 id="八、参考文档"><a href="#八、参考文档" class="headerlink" title="八、参考文档"></a>八、参考文档</h2><ol><li>influxDB系列教程 <a href="https://www.linuxdaxue.com/how-to-install-influxdb.html" target="_blank" rel="noopener">https://www.linuxdaxue.com/how-to-install-influxdb.html</a></li><li>influxDB原理：<a href="http://hbasefly.com/category/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">http://hbasefly.com/category/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;InfluxDB–时序数据库&quot;&gt;&lt;a href=&quot;#InfluxDB–时序数据库&quot; class=&quot;headerlink&quot; title=&quot;InfluxDB–时序数据库&quot;&gt;&lt;/a&gt;InfluxDB–时序数据库&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;xaMqU&quot;&gt;&lt;/a&gt;&lt;/
      
    
    </summary>
    
      <category term="数据库" scheme="http://blog.fedfans.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Influx" scheme="http://blog.fedfans.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Influx/"/>
    
    
      <category term="数据库" scheme="http://blog.fedfans.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Influx" scheme="http://blog.fedfans.com/tags/Influx/"/>
    
  </entry>
  
  <entry>
    <title>Angular Ivy改变了变化检测机制，你准备好了吗?</title>
    <link href="http://blog.fedfans.com//page/article/Angular_Ivy%E6%94%B9%E5%8F%98%E4%BA%86%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6,%E4%BD%A0%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%90%97/"/>
    <id>http://blog.fedfans.com//page/article/Angular_Ivy改变了变化检测机制,你准备好了吗/</id>
    <published>2018-10-28T15:25:00.000Z</published>
    <updated>2018-11-02T02:11:21.831Z</updated>
    
    <content type="html"><![CDATA[<p>编写中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写中&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular在新版本中，脏值检测重生了《译》</title>
    <link href="http://blog.fedfans.com//page/article/Angular%E5%9C%A8%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%AD%E8%84%8F%E5%80%BC%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E5%8F%91%E7%94%9F%E4%BA%86%E6%94%B9%E5%8F%98/"/>
    <id>http://blog.fedfans.com//page/article/Angular在新版本中脏值检测机制发生了改变/</id>
    <published>2018-10-28T08:15:00.000Z</published>
    <updated>2018-11-01T15:31:56.178Z</updated>
    
    <content type="html"><![CDATA[<p>Angular’s $digest is gone. Long live the digest!</p><p>我用 Angular.js 工作了几年，尽管受到了广泛的批评，但我依然认为这是一个很棒的框架。我从《Builing your own Angular.js》这本书入手，并且阅读了大部分框架的源码。所以我对 Angular.js 内部工作有了扎实的了解，并且很好的掌握了框架构建的思想。现在，我试图在更新后的 Angular 中 达到相同的理解水平，并且在版本之间映射想法。我发现，与互联网声称的 Angular 相反，Angular 还是借用了其前身的很多想法。</p><p>其中一个想法就是臭名鼎鼎的<a href="https://larseidnes.com/2014/11/05/angularjs-the-bad-parts/" target="_blank" rel="noopener">循环脏值检测</a>:</p><p>这个操作在 Angular.js 中非常昂贵。改变应用程序的任何一部分将成为数百或者上千个查找更改的函数的操作。这是 Angular.js 的基本组成部分，它对可以在 Angular 中构建的 UI 的大小设置了一个硬性限制，同时保持高性能。</p><p>如果对 Angular 的脏值检测实现机制有了很好的理解，那我们同样可以将应用程序设计地非常的高效。例如：有选择性地使用$scope.$digest()而不是$scope.$apply，而不是所有地方都是用$apply，拥抱不可变对象。但事实上，需要对底下实现有一定了解才能设计高性能的应用。</p><p>因此，大多数关于 Angular 的教程都不奇怪框架中没有更多的$digest 循环。这种观点很大程度取决于我们对脏值检测的理解，但是我认为，鉴于其目的，这是一种误导性的主张。它还在那里。是的，我们没有明确的范围和观察者，也没有调用$scope.$digest，但是检查遍历组件数的更改机制，调用隐式观察者炳更新 DOM 节点。最终完全被改写，并且被大大加强了。</p><p>这篇文章探讨了 Angular.js 和 Angular 在检测这块的实现的差异。并且对于 Angular.js 的开发者会有帮助，在他们迁移到 Angular 中。</p><h2 id="变更的需要"><a href="#变更的需要" class="headerlink" title="变更的需要"></a>变更的需要</h2><p>在我们开始之前，让我们记住为什么脏值检测会在 Angular.js 中出现。每个框架解决了数据模型和 UI 之间的同步问题。这个实事过程中最大的挑战就是更改检测。这也是当今大部分知名框架在实现之间最大的区别了。我打算写一篇深入介绍变更检测机制比较的文章。如果你想要被提醒到，请关注我谢谢:)</p><p>检查变更的方法有两种主要方法–通过用户告知框架或者自动探测更改。假设我们有下面这样一个对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;name: &apos;Angular&apos;&#125;;</span><br></pre></td></tr></table></figure><p>然后我们更新了 name 字段。我们的框架如何知道它发生了变化呢？一种方法是让用户来通知框架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    let person = &#123;name: &apos;Angular&apos;&#125;;</span><br><span class="line">    this.state = person;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// explicitly notifying React about the changes</span><br><span class="line">// and specifying what is about to change</span><br><span class="line">this.setState(&#123;name: &apos;Changed&apos;&#125;);</span><br></pre></td></tr></table></figure><p>或者强迫他在属性上使用一个包装器，以方便框架添加 setter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let app = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &apos;Hello Vue!&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// the setter is triggered so Vue knows what changed</span><br><span class="line">app.name = &apos;Changed&apos;;</span><br></pre></td></tr></table></figure><p>另一种方法是保存一个 name 属性的前一个值，并将其与当前值进行比较.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (previousValue !== person.name) // change detected, update DOM</span><br></pre></td></tr></table></figure><p>但什么时候应该被比较呢？我们应该在每次代码运行的时候运行检查机制。而且我们知道代码是异步时事件运行的-所谓的虚拟机 VM(反向、勾选)，我们可以在检测结束的时候进行检查操作。这就是 Angular.js 使用脏值检查的原因。所以我们可以将变更检测定义为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种更改检测机制，用于遍历组件树，检查每个组件的变化，并在组件属性变化发生Dom的更新</span><br></pre></td></tr></table></figure><p>如果我们使用了这个变更检测的定义，我断言主要机制并没有在新版本的 Angular 中改变。更改的知识实现变更检测的实现。</p><h2 id="Angular-js"><a href="#Angular-js" class="headerlink" title="Angular.js"></a>Angular.js</h2><p>Angular.js 使用了观察者和监听器的概念。一个观察者是一个用来返回一个被监听的对象的值的函数。通常，这些值是一个数据模型上的属性。但它并不总是数据模型上面的属性–我们也可以跟踪 scope 的状态，计算值，一个第三方组件。如果监听的值相比前面的值不一样了，angular 就会调用监听器。这个监听器通常是用来更新 UI 的。</p><p>这反应在$watch 函数的参数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch(watcher, listener);</span><br></pre></td></tr></table></figure><p>所以，如果我们有一个 person 这样的对象，这个对象里面有一个用于 html 里面展示的 name 字段，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>我们可以通过下面的方法跟踪这个属性并更新DOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$watch(() =&gt; &#123;</span><br><span class="line">return person.name</span><br><span class="line">&#125;, (value) =&gt; &#123;</span><br><span class="line">span.textContent = value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这基本上就像ng-bind这样的插值和指令。Angular.js使用指令来反射数据在DOM上的表现。最新的Angular不在那么做了。它使用了一个属性映射表来连接数据模型和DOM。现在的实现方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span [textContent]=&quot;person.name&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>由于我们有许多构成树的组件，并且每一个组件都有不同的数据模型，因此我们有一个跟组件树非常相似结构的观察者层次结构。观察者使用$scope进行分组，但这并不重要。</p><p>现在，在angular.js变更检测在这个观察者树结构中走过，并且更新DOM。通常，如果你使用现有的机制$time，$http，或者通过$scope.$apply或者$scope.$digest会触发一个异步事件。</p><p>监听器会按照严格的顺序进行处罚，首先是父组件，然后是子组件。这是有道理的，但它有一些不受欢迎的含义。观察者监听器可以具有各种副作用，包括更新父组件的属性。如果已经处理了父组件，然后一个子组件更新了父组件的属性，则不会检测到更改。这就是为什么更改检测需要必须多次运行才能保持稳定-以便不再有更改。并且此类运行的数量限制是10.这个涉及限制被认为是有缺陷的，Angular不允许这么做。</p><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular没有类似于Angular.js的观察者的概念。但是跟踪数据模型属性变化的函数还是存在。这些变更函数现在是由框架编译器生成，无法访问。此外，它们现在与底层DOM紧密项链。这些函数被存储在视图View上的<a href="https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/view.ts#L140" target="_blank" rel="noopener">updateRenderer</a>的属性名称中。</p><p>它们也非常的具体–它们只跟踪数据模型中的变化，而不像Angular.js中跟踪所有的内容。每一个组件由一个观察者，它跟踪模板中使用的所有组件属性。它不是返回一个值，而是返回的是每一个被跟踪属性调用<a href="https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/text.ts#L62" target="_blank" rel="noopener">checkAndUpdateTextInline</a>的函数。这个函数会对前面的值与当前值做对比，然后当改变的时候对DOM进行更改。</p><p>例如，对于AppComponent有如下一个模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Hello &#123;&#123;model.name&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>编译器会转换成下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function View_AppComponent_0(l) &#123;</span><br><span class="line">    // jit_viewDef2 is `viewDef` constructor</span><br><span class="line">    return jit_viewDef2(0,</span><br><span class="line">        // array of nodes generated from the template</span><br><span class="line">        // first node for `h1` element</span><br><span class="line">        // second node is textNode for `Hello &#123;&#123;model.name&#125;&#125;`</span><br><span class="line">        [</span><br><span class="line">            jit_elementDef3(...),</span><br><span class="line">            jit_textDef4(...)</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">        // updateRenderer function similar to a watcher</span><br><span class="line">        function (ck, v) &#123;</span><br><span class="line">            var co = v.component;</span><br><span class="line">            // gets current value for the component `name` property</span><br><span class="line">            var currVal_0 = co.model.name;</span><br><span class="line">            // calls CheckAndUpdateNode function passing</span><br><span class="line">            // currentView and node index (1) which uses</span><br><span class="line">            // interpolated `currVal_0` value</span><br><span class="line">            ck(v, 1, 0, currVal_0);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，即使现在以不同的方式实现了观察者，变更检测的循环还是存在。它更改了名称以更改检测周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在开发阶段，tick()会执行两次change detection cycle来确保没有新的改变被探测到。</span><br></pre></td></tr></table></figure><p>我之前提到过，在 angular.js 的变更探测会走一遍观察者树，并且更新 DOM。Angular 也做了非常相像的事情。当更改周期变动的时候，会走一遍组件树，并且调用渲染更新的函数。它是作为检查和更新视图过程的一部分完成的，我在关于 Angular 变化检测需要了解的所有内容中介绍了他。</p><p>就像 Angular.js 在教新版本中的 Angular，这个变更检测周期会被每一个异步事件触发。但是，由于 Angular 使用了 zone 来修复所有的异步时间，因此大部分事件不需要手动被触发。框架订阅了 onMicrotaskEmpty 时间，并在异步事件完成的时候收到通知。当 VMturn 中没有排队的微任务的时候就会触发此事件。但是，可以通过 view.detectChanges 或 ApplicationRef.tick 方法来手动触发更改检测。</p><p>Angular 强制使用了所谓的从上到下的单向数据流模型。在处理父组件被处理完毕后，不允许层次结构较低的结构更新父组件的属性。如果组件在 DoCheck 挂钩中更新了父组件模型属性，则可以正常工作，因为在检测到属性更改之前会调用此声明周期挂钩。但是，如果以其他方式去更新父组件的属性，例如，在处理更改后调用的 AfterViewChecked 挂钩是，则会在开发模式下获得以下报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression has changed after it was checked</span><br></pre></td></tr></table></figure><p>你可以在文章《<a href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" target="_blank" rel="noopener">您需要了解有关 <code>Expression Changed After It Has Been Checked Error</code>这个错误的所有信息</a>》了解更多的信息。</p><p>在生产环境中，这个错误将不会出现，只有当 Angular 执行下一个更改周期的时候才会探测到这个改动。</p><h2 id="使用生命周期钩子来跟踪变化"><a href="#使用生命周期钩子来跟踪变化" class="headerlink" title="使用生命周期钩子来跟踪变化"></a>使用生命周期钩子来跟踪变化</h2><p>在 Angular.js 中，每一个组件定义了一系列的跟踪者来跟踪下面这些信息:</p><ul><li>父组件的数据绑定</li><li>自己组件的属性</li><li>计算的值 ( computed value)</li><li>Angular 生态圈以外的第三方组件</li></ul><p>以下是如何在 Angular 中实现这些功能的。要跟踪父组件绑定属性，我们会使用 OnChange 生命周期的钩子。</p><p>我们可以使用 DoCheck 生命周期来跟踪自己组件属性和计算属性。因为这个周期会在 Angular 流程属性发生更改之前触发，因此我们可以执行任何我们操作以反应到界面上。</p><p>我们可以使用 OnInit 来监听 Angular 生态圈以外的变化，并且手动探测变化。</p><p>例如，我们有一个展示当前时间的组件。这个时间由 Time Servicce 提供。这是 Angular.js 中的实现方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function link(scope, element) &#123;</span><br><span class="line">    scope.$watch(() =&gt; &#123;</span><br><span class="line">        return Time.getCurrentTime();</span><br><span class="line">    &#125;, (value) =&gt; &#123;</span><br><span class="line">        $scope.time = value;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们在 Angular 中的实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class TimeComponent &#123;</span><br><span class="line">    ngDoCheck()</span><br><span class="line">    &#123;</span><br><span class="line">        this.time = Time.getCurrentTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子，如果我们有一个第三方的滑块的组件，没有集成到 Angular 的生态系统中，单我们需要展示当前的页面，我们只需要简单的包装秤一个 Angular 组件，来跟踪滑块的更改时间，并且手动触发更改来反映到 UI 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function link(scope, element) &#123;</span><br><span class="line">    slider.on(&apos;changed&apos;, (slide) =&gt; &#123;</span><br><span class="line">        scope.slide = slide;</span><br><span class="line"></span><br><span class="line">        // detect changes on the current component</span><br><span class="line">        $scope.$digest();</span><br><span class="line"></span><br><span class="line">        // or run change detection for the all app</span><br><span class="line">        $rootScope.$digest();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular 的想法也是一样的。以下是它的实现方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SliderComponent &#123;</span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        slider.on(&apos;changed&apos;, (slide) =&gt; &#123;</span><br><span class="line">            this.slide = slide</span><br><span class="line"></span><br><span class="line">            // detect changes on the current component</span><br><span class="line">            // this.cd is an injected ChangeDetector instance</span><br><span class="line">            this.cd.detectChanges();</span><br><span class="line"></span><br><span class="line">            // or run change detection for the all app</span><br><span class="line">            // this.appRef is an ApplicationRef instance</span><br><span class="line">            this.appRef.tick();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是全部的内容了!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Angular’s $digest is gone. Long live the digest!&lt;/p&gt;
&lt;p&gt;我用 Angular.js 工作了几年，尽管受到了广泛的批评，但我依然认为这是一个很棒的框架。我从《Builing your own Angular.js》这本书
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>5篇让你成为Angular变化检测专家《译》</title>
    <link href="http://blog.fedfans.com//page/article/%E4%BA%94%E7%AF%87%E8%AE%A9%E4%BD%A0%E6%88%90%E4%B8%BAAngular%E5%8F%98%E5%8C%96%E6%A3%80%E6%B5%8B%E4%B8%93%E5%AE%B6/"/>
    <id>http://blog.fedfans.com//page/article/五篇让你成为Angular变化检测专家/</id>
    <published>2018-10-28T07:00:00.000Z</published>
    <updated>2018-10-28T14:51:38.568Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的 8 个月中，我花了大部分空闲时间对 Angular 进行逆向工程。最让我着迷的主题是变化检测。我认为它是框架中最重要的部分，因为它负责”可见”工作，如 DOM 更新，输入绑定和查询列表更新。我的探索产生了一系列深入的文章，主要突出了变量检测机制的主要思想，并深入探讨了实现细节。在这篇文章中，我将它们放在一起，并简要描述了每个内容。阅读完之后，你会获取变化检测启发。</p><h2 id="理解变化检测"><a href="#理解变化检测" class="headerlink" title="理解变化检测"></a>理解变化检测</h2><p>以下五篇深入文章，将显著提升您对 Angular 中变更检测这块的了解。每一篇文章都是基于前一篇文章中解释的信息，因此我建议你按顺序阅读他们。</p><h3 id="Angular-在新版本中，脏值检测发生了新的改变"><a href="#Angular-在新版本中，脏值检测发生了新的改变" class="headerlink" title="Angular 在新版本中，脏值检测发生了新的改变"></a><a href="https://www.520stone.com/page/article/Angular%E5%9C%A8%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%AD%E8%84%8F%E5%80%BC%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E5%8F%91%E7%94%9F%E4%BA%86%E6%94%B9%E5%8F%98/" target="_blank" rel="noopener">Angular 在新版本中，脏值检测发生了新的改变</a></h3><p>这篇文章对 AngularJS 的脏值检测机制和 Angular 中的更改变更机制做了对比。它解释了对他们的需求，并展示了如何使用相同的脏检查概念构建它们。然后它提供了一些示例，演示了 Angular 中的生命周期钩子如何用作 AngularJS 中$wattch 的等效机制。它还显示了 Angular 与 AngularJS 的不同之处，因为它现在强制执行所谓的从上到下的所谓单向数据流。本文解释了实施背后的原因，它对架构的好处和限制。本文对于希望迁移到 Angular，正在使用 AngularJS 的开发者很有帮助。</p><h3 id="你是否依然仍未-Angular-中的变量检测需要-NgZone-zone-js"><a href="#你是否依然仍未-Angular-中的变量检测需要-NgZone-zone-js" class="headerlink" title="你是否依然仍未 Angular 中的变量检测需要 NgZone(zone.js)"></a><a href="https://blog.angularindepth.com/do-you-still-think-that-ngzone-zone-js-is-required-for-change-detection-in-angular-16f7a575afef" target="_blank" rel="noopener">你是否依然仍未 Angular 中的变量检测需要 NgZone(zone.js)</a></h3><p>这篇文章描述了如何在 zone.js 库之上实现了 NgZone，并解释了 NgZone 在框架中扮演的角色。与普遍看法相反，它并不是变化检测过程的一部分，而是用于触发它。本文首先演示了 Angular 如何在没有 NgZone 和 zone.js 的情况下检测更改，并执行渲染。然后它继续展示 NgZone 带来了什么价值以及它是如何实现的。本文的大部分内容致力于解释常用的公共 API，如 isStable，onUnstable 和 onMicrotaskEmpty.本文最后解释了使用像 GoogleAPI 这样的第三方库时未检测到的变化的常见缺陷。</p><h3 id="你需要知道的-Angular-中的更改检测的所有信息"><a href="#你需要知道的-Angular-中的更改检测的所有信息" class="headerlink" title="你需要知道的 Angular 中的更改检测的所有信息"></a><a href="https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f" target="_blank" rel="noopener">你需要知道的 Angular 中的更改检测的所有信息</a></h3><p>如果你想要牢固掌握变化检测机制，那么这篇文章是必读的。它提供了如何使用相关连接实现引擎的高级概述，以便进一步的探索。这篇文章先介绍了名为 View 的内部组件，并且介绍了变量检测是如何在 View 上面进行工作的。然后，它按执行顺序显示在更改检测期间执行的所有操作的列表。这些操作包括更新视图状态、渲染、处理输入绑定和调用生命周期钩子。最后，他解释了 ChangeDetectorRef 公共 API，如 detach，detectChanges 和 markForCheck，并提供了这些方法的简单示例。</p><h3 id="Angular-中-DOM-更新的机制"><a href="#Angular-中-DOM-更新的机制" class="headerlink" title="Angular 中 DOM 更新的机制"></a><a href="https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d" target="_blank" rel="noopener">Angular 中 DOM 更新的机制</a></h3><p>这篇文章深入探讨了将应用程序模型与 DOM,a.k.a 单向数据绑定或 DOM 渲染呈现工程的实现细节。此操作在更改变更过程中占据了中心的位置，因为她正是在 DOM 中呈现组件更改的原因。本文首先披露了有关 View 概念的其他详细的信息，特别是 View Factory 和几种基本类型的 View 节点。然后，它显示了更改检测机制如何通过插值或输入绑定为这些节点执行 DOM 更新设置。</p><h3 id="Angular-中的属性绑定更新机制"><a href="#Angular-中的属性绑定更新机制" class="headerlink" title="Angular 中的属性绑定更新机制"></a><a href="https://blog.angularindepth.com/the-mechanics-of-property-bindings-update-in-angular-39c0812bc4ce" target="_blank" rel="noopener">Angular 中的属性绑定更新机制</a></h3><p>与前一篇关于 DOM 更新的文章类似，本文升入探讨了更新子组件和指令的输入绑定过程的实现机制。它介绍了绑定定义的概念和其在变更检测过程中的作用。然后，它继续演示了编译器在处理属性绑定的模板语法时如何生成这些绑定定义。最后，它概述了再 View 节点上运行更改检测和指令的输入属性上分布过程。</p><h2 id="避免常见混淆"><a href="#避免常见混淆" class="headerlink" title="避免常见混淆"></a>避免常见混淆</h2><p>这里是一份附加的有价值的文章列表，主要是为了清除那些我常常在 StackOverflow 上面看到的关于变更检测方面的一些混淆。</p><h3 id="认为变更检测是深度优先的人，和广度优先的人通常都是对的"><a href="#认为变更检测是深度优先的人，和广度优先的人通常都是对的" class="headerlink" title="认为变更检测是深度优先的人，和广度优先的人通常都是对的"></a><a href="https://blog.angularindepth.com/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-8b6bf24a63e6" target="_blank" rel="noopener">认为变更检测是深度优先的人，和广度优先的人通常都是对的</a></h3><p>这篇文章回答了一个有趣的问题，Angular 是否首先检查当前组件（广度优先顺序）或其子节点（深度优先）的星弟节点。它显示了 Angular 在实际开始检查他们之间如何触发兄弟组件上的生命周期钩子，并解释了这种行为如何导致您得到错误的答案。</p><h3 id="你真的知道-Angular-中单向数据流的含义嘛"><a href="#你真的知道-Angular-中单向数据流的含义嘛" class="headerlink" title="你真的知道 Angular 中单向数据流的含义嘛?"></a><a href="https://blog.angularindepth.com/do-you-really-know-what-unidirectional-data-flow-means-in-angular-a6f55cefdc63" target="_blank" rel="noopener">你真的知道 Angular 中单向数据流的含义嘛?</a></h3><p>这篇文章介绍了单向数据绑定和单向数据流的区别。他演示了 Angular 与 AngularJS 之间更新输入绑定的过程的不同之处，以及这种差异在何处非常的重要。</p><h3 id="您需要了解有关-Expression-Changed-After-It-Has-Been-Checked-Error这个错误的所有信息"><a href="#您需要了解有关-Expression-Changed-After-It-Has-Been-Checked-Error这个错误的所有信息" class="headerlink" title="您需要了解有关 Expression Changed After It Has Been Checked Error这个错误的所有信息"></a><a href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" target="_blank" rel="noopener">您需要了解有关 <code>Expression Changed After It Has Been Checked Error</code>这个错误的所有信息</a></h3><p>这篇文章解释了 Angular 社区中频繁并经常被误解的错误背后的推理和机制。虽然一些开发人员将其视为一种错误，单实际上这是一个设计决策，通过将变更检测运行限制为单次运行来提高性能，而不是 AngularJS 中的大量运行($digest 运行).本文介绍了抛出错误有助于防止数据模型和 UI 之间的不一致问题。从而不会向用户展示的数据是错误的或者旧的数据。这篇文章主要由两部分构成，首先探讨了错误的原因，第二部分提出了可能的修复办法。他还解释了为什么在生产环境中为什么不会抛出这个问题。</p><h3 id="如果你认为ngDoCheck意味着你的组件正在被检查"><a href="#如果你认为ngDoCheck意味着你的组件正在被检查" class="headerlink" title="如果你认为ngDoCheck意味着你的组件正在被检查"></a><a href="https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5" target="_blank" rel="noopener">如果你认为<code>ngDoCheck</code>意味着你的组件正在被检查</a></h3><p>这篇文章为 OnPush 策略的组件触发 ngDoCheck 生命周期钩子的问题提供了详细的解答，即使这些组件的输入参数并没有发生改变。它解释了通常意外的事实，即在检查父组件时为子组件触发挂钩，并显示该机制如何触发 ngDoCheck，即使看起来没有理由这么做。本文第二部分通过演示一些例子来回答为什么我们需要 ngDoCheck 的问题。</p><h3 id="Angular-中构造函数和-ngOnInit-之间的本质区别"><a href="#Angular-中构造函数和-ngOnInit-之间的本质区别" class="headerlink" title="Angular 中构造函数和 ngOnInit 之间的本质区别"></a><a href="https://blog.angularindepth.com/the-essential-difference-between-constructor-and-ngoninit-in-angular-c9930c209a42" target="_blank" rel="noopener">Angular 中构造函数和 ngOnInit 之间的本质区别</a></h3><p>这篇文章中提供了一个完美的回答了最最流行的有关于 stackoverflow 上面的一个 Angular 问题，这个问题被 100K 查看，就是关于构造函数和 ngOnInit 之间的区别。本文给出了一个全面的比较，突出了使用的差异，并且还涉及了组件初始化的过程。</p><h2 id="Angular-Air-插曲"><a href="#Angular-Air-插曲" class="headerlink" title="Angular Air 插曲"></a>Angular Air 插曲</h2><p>我还强烈建议大家观看<a href="https://www.youtube.com/watch?v=WizqXZjztss&amp;feature=youtu.be" target="_blank" rel="noopener">Angular Air episode</a>，在那边我谈论了视图层的内部表示和更改检测渲染的部分。我还阐述了一些与区域相关的常见误解，以及使用<a href="https://angular.io/api/core/ChangeDetectorRef" target="_blank" rel="noopener">ChangeDetectorRef</a>手动控制变化检测。</p><h2 id="有关于-Angular-内部实现原理独一无二的书"><a href="#有关于-Angular-内部实现原理独一无二的书" class="headerlink" title="有关于 Angular 内部实现原理独一无二的书"></a>有关于 Angular 内部实现原理独一无二的书</h2><p>我已经开始写一本 Angular 内部架构的综合性书籍。它将取名为<inside angular="">。这本书深入介绍框架的架构，并且详细介绍了编译器、视图、DI、变更检测机制的工作原理。我还计划在加入一些关于性能优化和调试的例子实际例子。这本书大概 150-200 页左右，并将有大量的图表以方便大家的理解材料。如果你感兴趣，请查看您是否会购买一本关于 Angular internals 的书籍？该文章提供了一些书记的信息，并且包含了一个订阅列表，您可以用它来告诉我您是否有兴趣购买该书。</inside></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在过去的 8 个月中，我花了大部分空闲时间对 Angular 进行逆向工程。最让我着迷的主题是变化检测。我认为它是框架中最重要的部分，因为它负责”可见”工作，如 DOM 更新，输入绑定和查询列表更新。我的探索产生了一系列深入的文章，主要突出了变量检测机制的主要思想，并深入探
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular OnPush组件中ngDoCheck和AsyncPipe的区别</title>
    <link href="http://blog.fedfans.com//page/article/Angular_OnPush%E7%BB%84%E4%BB%B6%E4%B8%ADngDoCheck%E5%92%8CAsyncPipe%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.fedfans.com//page/article/Angular_OnPush组件中ngDoCheck和AsyncPipe的区别/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2018-10-28T10:05:56.657Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要深入介绍，在 Angular 中，关于如何手动控制变动改动。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg" alt=""></p><p>此文主要是为了答复 Shai 在推特上的提问。他咨询了关于用 ngDoCheck 来手动比较 values 的方法来替换使用推荐的 asyn 管道的方法 是否依然可行。这是一个比较好的提问，因为这需要对于 angular 给我们提供的 hook 有更多的了解，比如:检测机制，pipes，生命周期的 hook。接下来让我来说一下吧。</p><p>首先，我先演示如何手动触发 change detetion。这些技术使你可以更好的在 Angular 在输入绑定和异步值检查时做更好的比较。接下来让我与您分享对于这些解决方法在性能方面影响的一些看法吧。</p><p>我是一个在 ag-Grid 方面的开发拥护者。如果你对了解数据网格或者正在寻找 Angular 在数据网格这块的解决方案，可以阅读<a href="https://medium.com/ag-grid/get-started-with-angular-grid-in-5-minutes-83bbb14fac93" target="_blank" rel="noopener">Get started with Angular grid in 5 minutes</a>或者向我提一些问题。</p><p>接下来让我们开始吧。</p><h2 id="OnPush-Components"><a href="#OnPush-Components" class="headerlink" title="OnPush Components"></a>OnPush Components</h2><p>在 Angular 中，我们有一个非常常见的优化技能，就是去添加 ChangeDetectionStrategy.OnPush 到 component 的 decorator 的 metadata 中。假设我们有两个简单层次的组件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;b-comp&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这样的配置，Angular 每次都会对 A 和 B 组件始终运行更改检测。如果现在我们给 B 组件添加了 OnPush 的策略的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>只有在其输入绑定发生更改的时，Angular 才会对 B 组件运行更改检测。上面由于此时它并没有进行输入绑定，所以在启动期间，只会对 B 组件进行一次更改检测。</p><h2 id="手动触发变更检测"><a href="#手动触发变更检测" class="headerlink" title="手动触发变更检测"></a>手动触发变更检测</h2><p>那么是否有一种给 B 组件强制触发更改检测的方法呢？答案，当然是的，我们可以通过注入 changeDetectorRef，并且使用 markForCheck 方法来告知 Angular 当前组件需要进行更改检测。因为根据生命周期，NgDoCheck hook 会被触发，所以我们可以用下面的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `&lt;span&gt;I am B component&lt;/span&gt;`,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        this.cd.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，当 Angular 检查父组件 A 的时候，会对 B 进行变更检测。接下来让我们看看如何使用吧。</p><h2 id="输入绑定"><a href="#输入绑定" class="headerlink" title="输入绑定"></a>输入绑定</h2><p>我们说过，Angular 只会在绑定发生变化的时候，对 OnPush 的组件进行变更检测。所以让我们看一个输入绑定的例子。假设我们有一个通过从父组件传递下来的输入对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件 A 中，我们定义了一个对象，并且实现了 changeName 的方法，这个方法需要在单击按钮时，更新这个对象的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;button (click)=&quot;changeName()&quot;&gt;Trigger change detection&lt;/button&gt;</span><br><span class="line">        &lt;b-comp [user]=&quot;user&quot;&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;</span><br><span class="line">    user = &#123;name: &apos;A&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.user.name = &apos;B&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果现在我们运行这个例子，则再第一次变更检测之后，我们将会看到用户的 name 打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User name: A</span><br></pre></td></tr></table></figure><p>但是当我们点击了按钮，并且在回调函数中改变了变量的名字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changeName() &#123;</span><br><span class="line">    this.user.name = &apos;B&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名字并不会在屏幕上更新。我们知道这是因为 Angular 对 Input 的参数只进行浅比较，此处 user 变量的引用没有发生变化。那么我们怎么来解决这个问题呢?</p><p>好吧，我们可以在检测到差异时，手动检查名称并触发变化检测:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">    previousName = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        if (this.previousName !== this.user.name) &#123;</span><br><span class="line">            this.previousName = this.user.name;</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你运行了这个代码，你将在屏幕上看到更新的名字。</p><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p>现在，让我们的例子更复杂一些。我们将介绍一种基于 RxJs 的服务，它可以异步发出一个更新。它有点类似于 NgRx 体系结构。我将使用 BehaviorSubject 作为值的来源，因为我需要以初始值启动流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;a-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am A component&lt;/span&gt;</span><br><span class="line">        &lt;button (click)=&quot;changeName()&quot;&gt;Trigger change detection&lt;/button&gt;</span><br><span class="line">        &lt;b-comp [user]=&quot;user&quot;&gt;&lt;/b-comp&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class AComponent &#123;</span><br><span class="line">    stream = new BehaviorSubject(&#123;name: &apos;A&apos;&#125;);</span><br><span class="line">    user = this.stream.asObservable();</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.stream.next(&#123;name: &apos;B&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们在子组件中收到此用户变量流。我们需要订阅流并检查值是否更新。这样做的常用方法是使用异步管道。</p><h2 id="异步管道"><a href="#异步管道" class="headerlink" title="异步管道"></a>异步管道</h2><p>所以这里是子组件 B 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;(user | async).name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input() user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackblitz.com/edit/angular-q8n3qj?file=src%2Fapp%2Fa.component.ts" target="_blank" rel="noopener">查看例子</a>。但是有另一种不使用异步管道的方法吗？</p><h2 id="手动检查和更改检测"><a href="#手动检查和更改检测" class="headerlink" title="手动检查和更改检测"></a>手动检查和更改检测</h2><p>是的，我们可以手动检查值并在需要的时候来触发更改检测。正如我们开头的例子一样，我们可以使用 NgDoCheck 的生命周期的钩子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;b-comp&apos;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;span&gt;I am B component&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;User name: &#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    `,</span><br><span class="line">    changeDetection: ChangeDetectionStrategy.OnPush</span><br><span class="line">&#125;)</span><br><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input(&apos;user&apos;) user$;</span><br><span class="line">    user;</span><br><span class="line">    previousName = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user$.subscribe((user) =&gt; &#123;</span><br><span class="line">            this.user = user;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck() &#123;</span><br><span class="line">        if (this.previousName !== this.user.name) &#123;</span><br><span class="line">            this.previousName = this.user.name;</span><br><span class="line">            this.cd.markForCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以体验下: <a href="https://stackblitz.com/edit/angular-4xuug1?file=src%2Fapp%2Fb.component.ts" target="_blank" rel="noopener">例子</a></p><p>理想情况，我们希望从 NgDoCheck 移动我们的比较和更新逻辑并将其放到订阅回调中，因为那时新值将可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export class BComponent &#123;</span><br><span class="line">    @Input(&apos;user&apos;) user$;</span><br><span class="line">    user = &#123;name: null&#125;;</span><br><span class="line"></span><br><span class="line">    constructor(private cd: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        this.user$.subscribe((user) =&gt; &#123;</span><br><span class="line">            if (this.user.name !== user.name) &#123;</span><br><span class="line">                this.cd.markForCheck();</span><br><span class="line">                this.user = user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackblitz.com/edit/angular-lvtfve?file=src%2Fapp%2Fb.component.ts" target="_blank" rel="noopener">例子</a></p><p>有趣的是，这正是异步管道在幕后做的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Pipe(&#123;name: &apos;async&apos;, pure: false&#125;)</span><br><span class="line">export class AsyncPipe implements OnDestroy, PipeTransform &#123;</span><br><span class="line">  constructor(private _ref: ChangeDetectorRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  transform(obj: ...): any &#123;</span><br><span class="line">    ...</span><br><span class="line">    this._subscribe(obj);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (this._latestValue === this._latestReturnedValue) &#123;</span><br><span class="line">      return this._latestReturnedValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._latestReturnedValue = this._latestValue;</span><br><span class="line">    return WrappedValue.wrap(this._latestValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private _subscribe(obj): void &#123;</span><br><span class="line">    ...</span><br><span class="line">    this._strategy.createSubscription(</span><br><span class="line">        obj, (value: Object) =&gt; this._updateLatestValue(obj, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private _updateLatestValue(async: any, value: Object): void &#123;</span><br><span class="line">    if (async === this._obj) &#123;</span><br><span class="line">      this._latestValue = value;</span><br><span class="line">      this._ref.markForCheck();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那么哪一种解决方案更快"><a href="#那么哪一种解决方案更快" class="headerlink" title="那么哪一种解决方案更快?"></a>那么哪一种解决方案更快?</h2><p>现在我们知道了如何使用手动更改检测而不是异步管道，让我们回答我们最开始的问题。谁更快？</p><p>嗯，这取决于你如何比较他们，但在其他条件相同的情况下，手动方法会更快。我不认为这种区别是有形的。以下是为什么手动方法可以更快的几个例子。</p><p>就内存而言，您不需要创建 Pipe 类的实例。就编译而言，编译器不必花时间解析管道特定语法并生成管道特定输出。在运行时方面，您可以使用异步管道为组件上的每一个更改检测运行保存几个函数调用。这是为管道代码生成的 updateRenderer 函数的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function (_ck, _v) &#123;</span><br><span class="line">    var _co = _v.component;</span><br><span class="line">    var currVal_0 = jit_unwrapValue_7(_v, 3, 0, asyncpipe.transform(_co.user)).name;</span><br><span class="line">    _ck(_v, 3, 0, currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所见，异步管道的代码调用管道实例上的 transorm 方法以获取新值。管道将返回从订阅中收到的最新值。</p><p>将其与手动方法生成的普通方法进行比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function(_ck,_v) &#123;</span><br><span class="line">    var _co = _v.component;</span><br><span class="line">    var currVal_0 = _co.user.name;</span><br><span class="line">    _ck(_v,3,0,currVal_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是 Angular 在检查 B 组件时执行的功能。</p><h2 id="一些更有趣的事情"><a href="#一些更有趣的事情" class="headerlink" title="一些更有趣的事情"></a>一些更有趣的事情</h2><p>与执行浅比较的输入绑定不同，异步管道的实现变更不执行比较（感谢 Olena Horal 特别提到的）。它将每个新的 emission 作为更新处理，即使它与之前的 emission 相同。这是发成相同对象父组件 A 的实现。尽管如此，Angular 仍然运行 B 组件的变化检测:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class AComponent &#123;</span><br><span class="line">    o = &#123;name: &apos;A&apos;&#125;;</span><br><span class="line">    user = new BehaviorSubject(this.o);</span><br><span class="line"></span><br><span class="line">    changeName() &#123;</span><br><span class="line">        this.user.next(this.o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着每次发出新值时，都会标记具有异步管道的组件以进行检测。并且 Angular 将在下次运行变更检测时检查组件，即使该值未更改。</p><p>这有什么关系？好吧，在我们例子中，我们只对用户的属性名称该兴趣，因为我们在模板中使用它。我们并不关心整个对象以及对对象应用可能会改变的事实。如果名称相同，我们不需要重新渲染组件。但你无法用异步管道来避免这种情况。</p><p>NgDoCheck 本身并非没有问题:)由于只有在检查了父组件时才会触发钩子，如果其中一个父组件使用了 OnPush 策略并且在更改变更期间未做检查，则不会触发该钩子。因此，当您通过服务收到新值时，不能依赖它来触发更改检测。在这种情况下，我在订阅回调中使用 markForCheck 显示的解决方案是可行的方法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基本上，手动比较可以让您更好的控制检查。您可以定义何时检查组件。这与很多其他工具相同-手动控制为您提供了更大的灵活性，但您必须知道自己在做什么。为了获得这些知识，我鼓励您投入时间和精力来学习和阅读资源。</p><p>如果您担心调用 NgDoCheck 生命周期的评率，或者它会比管道变更更换更频繁的调用。首先请不要做。首先我们展示了上面的解决方案，您不使用异步流的手动方法中的钩子。其次，只有在检查父组件时才会调用钩子。如果未选中父组件，则不会调用该挂钩。关于管道，由于流中的浅层检查和更改引用，您将使用管道的转换方法火的相同数量的调用或甚至更多。</p><h2 id="想要了解更多有关-Angular-中变更检查的更多信息？"><a href="#想要了解更多有关-Angular-中变更检查的更多信息？" class="headerlink" title="想要了解更多有关 Angular 中变更检查的更多信息？"></a>想要了解更多有关 Angular 中变更检查的更多信息？</h2><p>首先，阅读<a href="https://www.520stone.com/page/article/五篇让你成为Angular变化检测专家/" target="_blank" rel="noopener">These 5 articles will make you an Angular Change Detection expert.</a>.如果你想要牢固掌握 Angular 中的变化检测机制，那么这个系列是必读的。每篇文章都以前一篇文章中解释的信息为基础，然后以高级的维度讲解实现细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要深入介绍，在 Angular 中，关于如何手动控制变动改动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angular7.0发布-虚拟滚动、拖拽等特性</title>
    <link href="http://blog.fedfans.com//page/article/Angular7-0%E5%8F%91%E5%B8%83-%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E3%80%81%E6%8B%96%E6%8B%BD%E7%AD%89%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.fedfans.com//page/article/Angular7-0发布-虚拟滚动、拖拽等特性/</id>
    <published>2018-10-18T23:38:06.000Z</published>
    <updated>2018-10-19T04:22:53.321Z</updated>
    
    <content type="html"><![CDATA[<p>2018年10月19日，Angular7.0发布了! 这是一个跨了major版本的版本，其中包括核心框架，Angular Material，还有Angular CLI跟主分支也进行了同步。这个版本在工具链方面提供了更多的特性，并且合并了一些主要参与者的分支的功能。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*CQKUmJrBs-523I4GOiEUaA.gif" alt=""><br>虚拟scrolling可以提高我们的应用性能</p><h1 id="如何升级到Angular7-0的版本"><a href="#如何升级到Angular7-0的版本" class="headerlink" title="如何升级到Angular7.0的版本"></a>如何升级到Angular7.0的版本</h1><p>还是跟以往一样，我们可以通过 <a href="https://update.angular.io" target="_blank" rel="noopener">https://update.angular.io</a>查看详细的文档和手册来升级我们的项目。同时告诉大家一个好消息，就是因为我们在V6.0的版本中做的工作，我们大部分的开发者可以通过一条命令就能从Angular6.0升级到Angular7.0版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng update @angular/cli @angular/core</span><br></pre></td></tr></table></figure><p>早期已经体验过这个升级过程的开发说，这次升级相比以往变得更快了，大部分升级过程仅仅花了不到10分钟就升级完了。</p><h1 id="CLI提示输入"><a href="#CLI提示输入" class="headerlink" title="CLI提示输入"></a>CLI提示输入</h1><p>现在Angular/cli工具会在当用户运行ng new 或者ng add @angular/material的时候，提示用户一些参数信息，来帮助用户使用routing或者scss功能的功能。</p><p>这个提示用户帮助创建项目的功能，已经被加入到@angular-devkit/schematics-cli这个工具中，关于schematics，又可以跳转到另一篇<a href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" target="_blank" rel="noopener">文章</a>,这样任何用schematics发布的用户可以通过添加x-promt到Schematics的配置项中。</p><p>如下schematic.json文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;routing&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;boolean&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Generates a routing module.&quot;,</span><br><span class="line">  &quot;default&quot;: false,</span><br><span class="line">  &quot;x-prompt&quot;: &quot;Would you like to add Angular routing?&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h1 id="应用性能方面"><a href="#应用性能方面" class="headerlink" title="应用性能方面"></a>应用性能方面</h1><p>还是跟以往一样，我们依旧关注着性能方面的改进，我们分析了大部分Angular生态圈这边的错误。我们发现有很多的开发者在生产环境中加入了reflect-metadata这个polyfill，这其实仅仅只需要在开发阶段加入即可。</p><p>为了解决这个问题，升级到Angular7.0的过程中，我们会自动从polyfills.ts文件中移除reflect-metadata这个，然后当我们使用JIT模式的编译的时候加入这个reflect-metadata，而在生产环境编译中默认移除这个。</p><p>在Angular7.0的版本中，我们会提醒新项目使用cli工具打包的时候，生成的包的大小。新应用，我们会在2MB大小的时候进行警告，而在5MB的时候直接报错。当然这个大小我们增加了配置项在angular.json文件中让我们进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;budgets&quot;: [&#123;</span><br><span class="line">  &quot;type&quot;: &quot;initial&quot;,</span><br><span class="line">  &quot;maximumWarning&quot;: &quot;2mb&quot;,</span><br><span class="line">  &quot;maximumError&quot;: &quot;5mb&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>关于包的提示的内容，我们会在Chrome上面进行显示。如下图:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*jXHBMok5cNnkXD8O0a8gAg.png" alt=""></p><h1 id="Angular-Material-amp-the-CDK"><a href="#Angular-Material-amp-the-CDK" class="headerlink" title="Angular Material &amp; the CDK"></a>Angular Material &amp; the CDK</h1><p>Material 设计组在2018年做了一个比较大的改动，具体改动，我们可以查看文档<a href="https://www.youtube.com/watch?v=1Dh8ZBQp9jo" target="_blank" rel="noopener">a big update</a>。Angular Material的用户在升级到Angular7.0的版本中，我们需要关注下在表现形式上面的一些微小的展示上的不同。<br>如下图：<br><img src="https://cdn-images-1.medium.com/max/1600/1*lgZYt3RBGM_c7HUcg85Zgg.png" alt=""></p><p>在angular material的CDK中，我们又利用了虚拟滚动和拖拽的功能，加入了DragDropModule或者叫Scrolling Module。</p><h2 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h2><p>虚拟滚动让DOM节点在一个list中进行加入和删除，让我们的在一个大型可滚动的应用中体验到更加流程的用户体验。</p><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;cdk-virtual-scroll-viewport itemSize=&quot;50&quot; class=&quot;example-viewport&quot;&gt;</span><br><span class="line">  &lt;div *cdkVirtualFor=&quot;let item of items&quot; class=&quot;example-item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/cdk-virtual-scroll-viewport&gt;</span><br></pre></td></tr></table></figure></p><p>如果想要了解更多关于 Virual Scrolling，可以查看<a href="https://material.angular.io/cdk/scrolling/overview" target="_blank" rel="noopener">文章</a></p><h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><p>如下图的拖拽效果:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*i30ZQdBC7CKbXXdOrUNQcg.gif" alt=""></p><p>在CDK中，我们加入了拖拽的功能，当用户移动的时候我们会自动的重绘元素就，这里又一些方法可以提供给我们，moveItemInArray，还有在列表间传送单元:transferArrayItem。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div cdkDropList class=&quot;list&quot; (cdkDropListDropped)=&quot;drop($event)&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; *ngFor=&quot;let movie of movies&quot; cdkDrag&gt;&#123;&#123;movie&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop(event: CdkDragDrop&lt;string[]&gt;) &#123;</span><br><span class="line">  moveItemInArray(this.movies, event.previousIndex, event.currentIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要了解更多关于拖拽这块的，可以查看<a href="https://material.angular.io/cdk/drag-drop/overview" target="_blank" rel="noopener">文章</a></p><h1 id="同时我们优化了selects的可用性"><a href="#同时我们优化了selects的可用性" class="headerlink" title="同时我们优化了selects的可用性"></a>同时我们优化了selects的可用性</h1><p>我们通过在mat-form-field这个标签中使用原生select节点之中，提高了应用的可用性。原生的select表现出更好的性能，可用性和可获得性，但是我们也将继续保留mat-select做为mat-form-fields的内置标签使用。<br>(这个也是在Angular Material中的)</p><p>如果想要了解mat-select和mat-form-field的内容，我们可以查看<a href="https://material.angular.io/components/select/overview" target="_blank" rel="noopener">链接</a></p><h1 id="Angular-Elements"><a href="#Angular-Elements" class="headerlink" title="Angular Elements"></a>Angular Elements</h1><p>Angular Elements现在通过标准的custom elements，支持了内容的保护。<br>如下:</p><p><my-custom-element>This content can be projected!</my-custom-element></p><p>关于Angular Elements，可以看我的翻译的文章<a href="https://www.520stone.com/page/article/%E9%80%9A%E8%BF%87Angular6%E5%88%9B%E5%BB%BACustom-Elements-Web-Components/" target="_blank" rel="noopener">通过Angular6创建Custom Elements/Web Components</a></p><h1 id="Angular项目参与者提供的功能"><a href="#Angular项目参与者提供的功能" class="headerlink" title="Angular项目参与者提供的功能"></a>Angular项目参与者提供的功能</h1><p>Angular在社区这块非常感激大家的贡献，同时我们在一些社区项目中参与了，并且一些项目已经正式使用了。如下图:<br>StackBlitz 2.0 Supports multipane editing and the Angular Language Service<br><img src="https://cdn-images-1.medium.com/max/1600/1*5dDsNd840QO7btuZUsnBYw.gif" alt=""></p><p><a href="https://angularconsole.com/" target="_blank" rel="noopener">Angular Console</a>一个可以被下载的console，用来做项目启动和运行的。<br><a href="https://github.com/angular/angularfire2" target="_blank" rel="noopener">@angular/fire</a> AngularFIle有了一个新的报名，他有当前最稳定的版本<br><a href="https://docs.nativescript.org/code-sharing/intro" target="_blank" rel="noopener">NativeScript</a>通过NativeScript，让我们既能让我们项目运行成web，也能运行成可安装的手机应用。<br><a href="https://stackblitz.com/fork/angular" target="_blank" rel="noopener">StackBlitz</a>StackBlitz2.0已经发布</p><h1 id="升级手册"><a href="#升级手册" class="headerlink" title="升级手册"></a>升级手册</h1><p>我们在不断优化我们的使用手册。现在官方的angular.io中，已经包含了angular-cli的文档，文档地址:<a href="https://angular.io/cli" target="_blank" rel="noopener">地址</a></p><h1 id="依赖升级"><a href="#依赖升级" class="headerlink" title="依赖升级"></a>依赖升级</h1><p>Angular7.0依赖于Typescript3.1, RxJS6.3，Node10（我们也会支持Node8）</p><h1 id="Ivy怎么样了？"><a href="#Ivy怎么样了？" class="headerlink" title="Ivy怎么样了？"></a>Ivy怎么样了？</h1><p>我们还在努力为我们下一代的渲染引擎，Ivy努力。Ivy正在开发中，但还不是v7里面的功能。我们正在验证在一些过去应用中的可用性，并且最快的预计下个月，我们会给出Ivy的预览效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年10月19日，Angular7.0发布了! 这是一个跨了major版本的版本，其中包括核心框架，Angular Material，还有Angular CLI跟主分支也进行了同步。这个版本在工具链方面提供了更多的特性，并且合并了一些主要参与者的分支的功能。&lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="前端" scheme="http://blog.fedfans.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>通过Angular6创建Custom Elements/Web Components《翻译》</title>
    <link href="http://blog.fedfans.com//page/article/%E9%80%9A%E8%BF%87Angular6%E5%88%9B%E5%BB%BACustom-Elements-Web-Components/"/>
    <id>http://blog.fedfans.com//page/article/通过Angular6创建Custom-Elements-Web-Components/</id>
    <published>2018-09-27T15:41:25.000Z</published>
    <updated>2018-09-29T16:08:31.329Z</updated>
    
    <content type="html"><![CDATA[<p>通过新版本的Angular CLI（version 6，released 2018-04-03）和新的Angular成员（Angular Elements这个模块），让创建custom elements变得尤为简单。</p><p>如果你不知道custom elements是什么或者它跟Angular有什么关系，那大家可以查看<a href="https://www.youtube.com/watch?v=9zyq7FcIuvM&amp;feature=youtu.be" target="_blank" rel="noopener">视频教程</a>来进行了解这些内容，对这些的了解有助你对文中的内容有更多的了解。</p><p>那么，不多讲，让我们来看看代码怎么写吧~</p><h2 id="一、安装Angular-CLI-6的版本并且初始化一个工程"><a href="#一、安装Angular-CLI-6的版本并且初始化一个工程" class="headerlink" title="一、安装Angular CLI 6的版本并且初始化一个工程"></a>一、安装Angular CLI 6的版本并且初始化一个工程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @angular/cli</span><br><span class="line">ng new elements-demo --prefix custom</span><br></pre></td></tr></table></figure><p>我们并不需要做什么其他特殊的事情，为了web component那边，我们一般是需要以prefix前缀，此处相当于我们生成的web component元素，都是custom-{}这样的。</p><h2 id="二、添加-angular-elements和polyfill"><a href="#二、添加-angular-elements和polyfill" class="headerlink" title="二、添加@angular/elements和polyfill"></a>二、添加@angular/elements和polyfill</h2><p>为了能使用这个功能，我们需要引入Angular的这个组件包以及一个polyfill兼容包。操作方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng add @angular/elements</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6525544/46158492-8cf99680-c2b0-11e8-8956-dfb3974f4898.png" alt="image"></p><h2 id="三、创建一个Component"><a href="#三、创建一个Component" class="headerlink" title="三、创建一个Component"></a>三、创建一个Component</h2><p>下面我们来创建一个含有Input和Output的Component，来了解它是怎么转变为能被浏览器识别的custom elements。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g component button --inline-style --inline-template -v Native</span><br></pre></td></tr></table></figure></p><p>最终，会帮我们在src/app中生成一个文件夹button，然后里面有个ButtonComponent。</p><p>然后我们加入一些样式和模板，最终button.component.ts看起来如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, EventEmitter, Input, OnInit, Output, ViewEncapsulation&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'custom-button'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button (click)="handleClick();"&gt;&#123;&#123;label&#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  styles: [<span class="string">`</span></span><br><span class="line"><span class="string">    button&#123;</span></span><br><span class="line"><span class="string">      border: solid 3px;</span></span><br><span class="line"><span class="string">      padding: 8px 10px;</span></span><br><span class="line"><span class="string">      background: #bada55;</span></span><br><span class="line"><span class="string">      font-size: 20px;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>],</span><br><span class="line">  encapsulation: ViewEncapsulation.ShadowDom <span class="comment">// 此处我把Native改成了ShadowDom，因为Native从v6.1.0开始废弃了</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ButtonComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  <span class="meta">@Input</span>() label: <span class="built_in">String</span> = <span class="string">'default label'</span>;</span><br><span class="line">  <span class="meta">@Output</span>() action: EventEmitter&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">private</span> clicksCounts = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.action.emit(<span class="keyword">this</span>.clicksCounts++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、注册Component到NgModule"><a href="#四、注册Component到NgModule" class="headerlink" title="四、注册Component到NgModule"></a>四、注册Component到NgModule</h2><p>接下来就是至关重要的一步：我们通过使用Angular里面的createCustomElement这个函数来创建一个能被浏览器原生函数customElements.define使用的class。</p><p>Angular官方文档是这么描述的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createCustomElement Builds a class that encapsulates the functionality of the provided component and uses the configuration information to provide more context to the class. Takes the component factory’s inputs and outputs to convert them to the proper custom element API and add hooks to input changes.</span><br><span class="line">The configuration’s injector is the initial injector set on the class, and used by default for each created instance.This behavior can be overridden with the static property to affect all newly created instances, or as a constructor argument for one-off creations.</span><br></pre></td></tr></table></figure></p><p>然后同时，我们需要将ButtonComponent放到entryComponents里面，然后我们把原本工程自动生成的app.component.ts这些删掉。</p><p>最终我们的app.module.ts长这个样子:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Injector, NgModule&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ButtonComponent &#125; <span class="keyword">from</span> <span class="string">'./button/button.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createCustomElement&#125; <span class="keyword">from</span> <span class="string">'@angular/elements'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    ButtonComponent,</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  entryComponents: [ButtonComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> injector: Injector</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> customButton = createCustomElement(ButtonComponent, &#123;injector&#125;);</span><br><span class="line">    customElements.define(<span class="string">'custom-button'</span>, customButton);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五、编译、压缩并测试我们的代码"><a href="#五、编译、压缩并测试我们的代码" class="headerlink" title="五、编译、压缩并测试我们的代码"></a>五、编译、压缩并测试我们的代码</h2><p>我们通过http-server来测试我们的代码，所以我们先安装下这个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i http-server -D</span><br></pre></td></tr></table></figure></p><p>通常，我们使用ng build命令来编译angular的代码，然后它会帮我们生成四个文件(runtime.js, script.js, polyfills.js和main.js)，然后我们将其合并成一个js文件，为了合并方便我们让编译出来的去hash一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build --prod --output-hashing=none</span><br></pre></td></tr></table></figure></p><p>最终生成到dist/elements-demo里面的，是四个不带hash的js文件。然后我们通过gzip然后变成一个js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dist/elements-demo/&#123;runtime,polyfills,scripts,main&#125;.js | gzip &gt; elements.js.gz</span><br></pre></td></tr></table></figure></p><p>然后我们在项目根目录下创建一个index.html文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"elements.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">custom-button</span> <span class="attr">label</span>=<span class="string">"First value"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'custom-button'</span>);</span></span><br><span class="line"><span class="javascript">  button.addEventListener(<span class="string">'action'</span>, (event)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">`action emitted : <span class="subst">$&#123;event.detail&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;button.label=<span class="string">'Second Value;'</span>&#125;, <span class="number">3000</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后我们在package.json里面的scripts里面加入这几个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;ng build --prod --output-hashing=none&quot;,</span><br><span class="line">&quot;package&quot;: &quot;cat dist/elements-demo/&#123;runtime,polyfills,scripts,main&#125;.js | gzip &gt; elements.js.gz&quot;,</span><br><span class="line">&quot;serve&quot;: &quot;http-server --gzip&quot;</span><br></pre></td></tr></table></figure></p><p>然后我们通过运行 npm run build &amp;&amp; npm run package，最后运行npm run serve.<br>然后我们就能看到我们web Components的页面效果了。</p><h2 id="六、收尾"><a href="#六、收尾" class="headerlink" title="六、收尾"></a>六、收尾</h2><p>回顾下，操作中最关键的是什么？总结一下：</p><ol><li>ng add @angular/elements库</li><li>用createCustomElement创建custom elements并 customElements.define去register custom elements</li><li>合并我们生成的js文件到一个压缩包</li></ol><p>看起来并不难对吧？所以我个人也是非常激动，这是这么简单的一个过程。这将在这个使用过程中，能对原先旧项目改造的时候比较局部而简单，不需要大动干戈。</p><p>而且我们通过ls -trlh 来查看生成出来的文件的大小。elements.js.gz只有紧紧70kb，考虑到他已经涵盖了一个angular在内部，所以已经是非常可观的结果了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过新版本的Angular CLI（version 6，released 2018-04-03）和新的Angular成员（Angular Elements这个模块），让创建custom elements变得尤为简单。&lt;/p&gt;
&lt;p&gt;如果你不知道custom elements
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Angular" scheme="http://blog.fedfans.com/categories/%E5%89%8D%E7%AB%AF/Angular/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Koa相关源码阅读系列</title>
    <link href="http://blog.fedfans.com//page/article/Node%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97/"/>
    <id>http://blog.fedfans.com//page/article/Node相关源码阅读系列/</id>
    <published>2018-09-19T00:06:06.000Z</published>
    <updated>2018-09-19T04:37:06.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系列篇"><a href="#系列篇" class="headerlink" title="系列篇"></a>系列篇</h2><ol><li>Koa源码(阅读进度：0%)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址: https://github.com/koajs/koa</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="2"><li>Koa-Router源码（阅读进度：100%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="3"><li>Koa-compose源码（阅读进度：100%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址: https://github.com/koajs/compose</span><br></pre></td></tr></table></figure></li></ol><p>解析文章：</p><ol start="4"><li>Koa-bodyparser源码（阅读进度：0%）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：https://github.com/koajs/bodyparser</span><br></pre></td></tr></table></figure></li></ol><p>解析文章:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系列篇&quot;&gt;&lt;a href=&quot;#系列篇&quot; class=&quot;headerlink&quot; title=&quot;系列篇&quot;&gt;&lt;/a&gt;系列篇&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Koa源码(阅读进度：0%)&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/"/>
    
      <category term="Koa" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/Koa/"/>
    
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
      <category term="源码阅读" scheme="http://blog.fedfans.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Node.js里面import和require一样吗？</title>
    <link href="http://blog.fedfans.com//page/article/Node.js%E9%87%8C%E9%9D%A2import%E5%92%8Crequire%E4%B8%80%E6%A0%B7%E5%90%97/"/>
    <id>http://blog.fedfans.com//page/article/Node.js里面import和require一样吗/</id>
    <published>2018-09-10T12:28:31.000Z</published>
    <updated>2018-09-10T13:32:10.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>本文主要讲解内容：import * as http from ‘http’; 和 const http = require(‘http’)这两种写法是否效果是相同的？</p><h2 id="问题场景篇"><a href="#问题场景篇" class="headerlink" title="问题场景篇"></a>问题场景篇</h2><p>我的ts的代码遇到一个情况，import * as http from ‘http’; 和 const http = require(‘http’)，这两个表现不一样。</p><p>如下代码: </p><p>A.ts<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shimmer <span class="keyword">from</span> <span class="string">'shimmer'</span>;</span><br><span class="line"></span><br><span class="line">shimmer.wrap(http, <span class="string">'createServer'</span>, <span class="function"><span class="params">original</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, requestListener: <span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"====&gt;"</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"2222"</span>)</span><br><span class="line">       <span class="comment">// 此处hook最底层的http,createServer</span></span><br><span class="line">       <span class="comment">// @ts-ignore</span></span><br><span class="line">       <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>A.ts是我封装的代码精简版，内部我使用shimmer对这个http的createServer这个函数进行hook，然后方便做代码http接口调用情况的统计。</p><p>然后main.ts是业务系统里面的代码，内部我们常常使用的是var koa = require(‘koa’)，koa底层肯定是http的createServer，所以我们此处用var http = require(‘http’)来模拟。</p><p>main.ts(业务代码里面，假设是require(‘http’))<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = http.createServer(<span class="function">(<span class="params">req: <span class="built_in">any</span>, res : <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">    res.end(<span class="string">'okay'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行后发现A.ts包里面如果我用import * as http from ‘http’ 不能hook对应的createServer的代码，但是我用const http = require(‘http’)就可以hook。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>然后将对应的ts代码编译代码后，发现import 的代码编译成了下面这种代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __importStar = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__importStar) || <span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mod &amp;&amp; mod.__esModule) <span class="keyword">return</span> mod;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (mod != <span class="literal">null</span>) <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> mod) <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(mod, k)) result[k] = mod[k];</span><br><span class="line">    result[<span class="string">"default"</span>] = mod;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> http = __importStar(<span class="built_in">require</span>(<span class="string">"http"</span>));</span><br></pre></td></tr></table></figure></p><p>按理，如我们标题一样，不应该是import * as http from ‘http’，应该等于const http= require(‘http’)吗?所以为何不是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br></pre></td></tr></table></figure></p><p>呢？不然我hook的其实是这个<strong>importStar里面这个result这个新的{}对象上面的createServer这个函数。那我们谷歌查询</strong>importStar，</p><p>最终，查到原来是ts的配置项中的esModuleInterop被设置成了true导致的。我们查看tsconfig.json文件里面的描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &apos;allowSyntheticDefaultImports&apos;</span><br></pre></td></tr></table></figure></p><p>相当于是为了做一个CommonJS和es modules这边的一个互通，会帮忙新建一个namespace objects。所以相当于这个__importStar是为了跟es modules那边有关系。</p><p>解决办法:把tsconfig.json里面这个特性关掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esModuleInterop: false</span><br></pre></td></tr></table></figure></p><h2 id="继续深入了解"><a href="#继续深入了解" class="headerlink" title="继续深入了解"></a>继续深入了解</h2><p>那我们就去看一下babel那块对于import这块的处理，我们写一个main.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure></p><p>然后项目安装babel的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br><span class="line"></span><br><span class="line"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span><br><span class="line">$ npm install --save-dev babel-preset-stage-0</span><br><span class="line">$ npm install --save-dev babel-preset-stage-1</span><br><span class="line">$ npm install --save-dev babel-preset-stage-2</span><br><span class="line">$ npm install --save-dev babel-preset-stage-3</span><br></pre></td></tr></table></figure></p><p>然后新建一个文件.babelrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;es2015&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们通过调用babel main.js –out-file out.js,查看过babel之后的这个包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = _interopRequireWildcard(_http);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireWildcard</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) &#123; <span class="keyword">return</span> obj; &#125; <span class="keyword">else</span> &#123; <span class="keyword">var</span> newObj = &#123;&#125;; <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123; <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123; <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; &#125; &#125; newObj.default = obj; <span class="keyword">return</span> newObj; &#125; &#125;</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure><p>然后我们也看到了一个类似__importStar这样的函数，也就是_interopRequireWildcard，也是内部去创建了一个{}这个对象。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以我们最终可以得到一个结论，babel这边<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br></pre></td></tr></table></figure></p><p>其实跟const http = require(‘http’)是有区别的，babel这边会帮我们生成一个类似namespace这样的东西。相当于这个文件里面里面http是处于一个namespace里面的，两个文件都import * as http from ‘http’; 如果其中一个文件修改了，则另外一个是不会被修改的。</p><p>然后typescript编译器那边，给我们加了这样一个属性，就是是否需要这种特性，也就是配置项: esModuleInterop</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那对于我的需求来说，我是为了让调用这个npm方的人，对于大家调用的底层的http包进行hook，所以我不希望有这样一个namespace包起来，所以我的ts代码里面就需要把这个esModuleInterop给关闭掉。最终编译后的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="comment">//简称这个地方不会帮我们包一层namespace</span></span><br></pre></td></tr></table></figure><p>所以Node.js里面，typescript，关于模块引用，我们可以选择用es module的形式去引用一个包，也可以用commonJS的方式去引用一个包，如果你是用es6在写。那es6那边你import了一个包，那就会多一个namespace这样的东西。如果有不对，请帮忙指正下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;本文主要讲解内容：import * as http from ‘http’; 和 const http = require(
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/Node/"/>
    
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
      <category term="问题" scheme="http://blog.fedfans.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Pandora源码-Pandora-dashboard(一)</title>
    <link href="http://blog.fedfans.com//page/article/Pandora%E6%BA%90%E7%A0%81-Pandora-dashboard(%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.fedfans.com//page/article/Pandora源码-Pandora-dashboard(一）/</id>
    <published>2018-08-29T14:13:18.000Z</published>
    <updated>2018-08-30T16:40:09.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pandora是阿里，一个可管理、可度量、可追踪的Node.js应用管理器。文档地址：<a href="http://www.midwayjs.org/pandora/zh-cn/" target="_blank" rel="noopener">http://www.midwayjs.org/pandora/zh-cn/</a> ，<br>仓库地址：<a href="https://github.com/midwayjs/pandora/" target="_blank" rel="noopener">https://github.com/midwayjs/pandora/</a> 和  <a href="https://github.com/midwayjs/pandora-dashboard。" target="_blank" rel="noopener">https://github.com/midwayjs/pandora-dashboard。</a></p><h2 id="Pandora-dashboard介绍"><a href="#Pandora-dashboard介绍" class="headerlink" title="Pandora-dashboard介绍"></a>Pandora-dashboard介绍</h2><p>这个是对应的Pandora的一个web应用，用来查看pandora应用管理器里面应用的情况。运行方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i pandora-dashboard -g # 全局安装，会全局注册一个命令 pandora-dashboard-dir</span><br><span class="line">$ pandora start --name dashboard `pandora-dashboard-dir` # 使用该命令获得路径，用于启动</span><br></pre></td></tr></table></figure></p><p>然后访问网址: <a href="http://127.0.0.1:9081/" target="_blank" rel="noopener">http://127.0.0.1:9081/</a>, 他的网页效果：</p><p><img src="https://user-images.githubusercontent.com/6525544/44789504-4c363100-abcf-11e8-9066-6501928f257a.png" alt=""></p><p>浏览器通过9801端口访问这个dashboard，Dashboard内部的结构总体如下图：</p><p><img src="https://user-images.githubusercontent.com/6525544/44789098-54da3780-abce-11e8-8814-e2eec12211ff.png" alt=""></p><p>然后这个代码比较简单，总体是一个typescript写的一个koa程序，然后项目结构如下图:</p><p><img src="https://user-images.githubusercontent.com/6525544/44789590-8d2e4580-abcf-11e8-8b0e-6e839bab9254.png" alt=""></p><p>Impl文件夹内部是对应的router，然后Home会去取上面的html相关的，static取对应的js，css相关的。然后Actuator.ts则是调用7002端口里面的信息。<br>Stdout，DebuggerProxy都新建了对应的websocket跟后端进行通信输出对应信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体我们看到dashboard这层，不像PM2那边的server是做了中心化存储，可以在中心进行查看各机器的信息。而Pandora当前是单机器装对应的Pandora和Pandora-dashboard，无法关于多台机器上面的Pandora的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Pandora是阿里，一个可管理、可度量、可追踪的Node.js应用管理器。文档地址：&lt;a href=&quot;http://www.midwayj
      
    
    </summary>
    
      <category term="Pandora源码分析" scheme="http://blog.fedfans.com/categories/Pandora%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pandora" scheme="http://blog.fedfans.com/tags/Pandora/"/>
    
      <category term="NodeJs" scheme="http://blog.fedfans.com/tags/NodeJs/"/>
    
      <category term="Node监控" scheme="http://blog.fedfans.com/tags/Node%E7%9B%91%E6%8E%A7/"/>
    
      <category term="JavaScript" scheme="http://blog.fedfans.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我博客的前世今生</title>
    <link href="http://blog.fedfans.com//page/article/%E6%88%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://blog.fedfans.com//page/article/我博客的前世今生/</id>
    <published>2018-08-28T14:13:18.000Z</published>
    <updated>2018-08-31T04:22:26.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我博客的前世今生"><a href="#我博客的前世今生" class="headerlink" title="我博客的前世今生"></a>我博客的前世今生</h2><p>原来的博客是非静态，是用vue的nuxtjs的ssr渲染，<a href="http://www.520stone.com" target="_blank" rel="noopener">www.520stone.com</a> ，后台是springboot+spring cloud相关技术栈全部手写的。<br>现在迁移到github page里面，不然每次要续费服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我博客的前世今生&quot;&gt;&lt;a href=&quot;#我博客的前世今生&quot; class=&quot;headerlink&quot; title=&quot;我博客的前世今生&quot;&gt;&lt;/a&gt;我博客的前世今生&lt;/h2&gt;&lt;p&gt;原来的博客是非静态，是用vue的nuxtjs的ssr渲染，&lt;a href=&quot;http://w
      
    
    </summary>
    
      <category term="日常杂记" scheme="http://blog.fedfans.com/categories/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="http://blog.fedfans.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杂记" scheme="http://blog.fedfans.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于服务器上面搭建了gitlab遇到的问题</title>
    <link href="http://blog.fedfans.com//page/article/45/"/>
    <id>http://blog.fedfans.com//page/article/45/</id>
    <published>2018-07-12T14:35:14.000Z</published>
    <updated>2018-08-31T05:34:28.039Z</updated>
    
    <content type="html"><![CDATA[<p>原先在自己电脑搭建了gitlab私服，但是由于要使用gitlab-ci，所以我就在阿里云服务器上面搭建了gitlab私服。</p><p>问题一：gitlab私服卡啊？</p><p>所以解决这个问题，就升级配置，当前使用了1G 2G内存，同时配置对应的swap，最终解决，如果服务器配置很差，升个级吧。</p><p>问题二：gitlab-ci的过程中，开头配置在相同电脑，然后一旦我提交了代码后，gitlab就无法访问了，同时我的站点也无法访问了？</p><p>首先我想法：cpu，带宽。</p><p>带宽：那我配置下我gitlab域名的host，这样可以通过127.0.0.1走本地，那带宽就不用占用我的带宽了，毕竟带宽这么贵。</p><p>cpu：处理了上面这种情况，问题还是在，那想法cpu，就是执行我的部署脚本的时候cpu占用大。后来发现这个好像并不影响。</p><p>最后发现是编译过程比较耗cpu，所以最终我把这个编译，放到一个小阿里云服务器，配置一个gitlab-runner解决。</p><p>最终，代码提交，执行gitlab-ci操作，编译部署，完美~不会影响gitlab和自己站点的访问了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原先在自己电脑搭建了gitlab私服，但是由于要使用gitlab-ci，所以我就在阿里云服务器上面搭建了gitlab私服。&lt;/p&gt;
&lt;p&gt;问题一：gitlab私服卡啊？&lt;/p&gt;
&lt;p&gt;所以解决这个问题，就升级配置，当前使用了1G 2G内存，同时配置对应的swap，最终解决，
      
    
    </summary>
    
      <category term="问题篇" scheme="http://blog.fedfans.com/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
    
      <category term="Gitlab" scheme="http://blog.fedfans.com/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器配置swap分区</title>
    <link href="http://blog.fedfans.com//page/article/44/"/>
    <id>http://blog.fedfans.com//page/article/44/</id>
    <published>2018-07-11T14:52:16.000Z</published>
    <updated>2018-08-31T05:30:13.365Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yq.aliyun.com/articles/52098" target="_blank" rel="noopener">https://yq.aliyun.com/articles/52098</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/52098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/articles/52098&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="服务器" scheme="http://blog.fedfans.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://blog.fedfans.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于大型angular项目编译问题</title>
    <link href="http://blog.fedfans.com//page/article/43/"/>
    <id>http://blog.fedfans.com//page/article/43/</id>
    <published>2018-07-11T14:11:25.000Z</published>
    <updated>2018-10-13T06:19:52.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当angular项目比较庞大的时候，打包时间就会比较慢。然后这个时候会出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[22517:0x102802400]   176590 ms: Mark-sweep 1367.9 (1430.1) -&gt; 1367.9 (1430.1) MB, 1351.8 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[22517:0x102802400]   178544 ms: Mark-sweep 1367.9 (1430.1) -&gt; 1367.9 (1427.1) MB, 1771.4 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[22517:0x102802400]   180071 ms: Mark-sweep 1367.9 (1427.1) -&gt; 1367.9 (1427.1) MB, 1526.6 / 0.0 ms  last resort GC in old space requested</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">Security context: 0x2f04b2e25529 &lt;JSObject&gt;</span><br><span class="line">    1: forEachChild [/Users/stone-jin/Downloads/metronic_v5.2 3/metronic_v5.2/angular/dist/demo/default/node_modules/typescript/lib/typescript.js:~11931] [pc=0x305175bbd919](this=0x2f04ace04a51 &lt;Object map = 0x2f04b1451ae9&gt;,node=0x2f04692c72a1 &lt;NodeObject map = 0x2f04352d8e11&gt;,cbNode=0x2f0421f75a69 &lt;JSFunction visitNode (sfi = 0x2f0414f144b9)&gt;,cbNodes=0x2f04fc6822d1 &lt;undefined&gt;)</span><br><span class="line">    2: arguments...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br><span class="line"> 1: node::Abort() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 2: node::FatalTryCatch::~FatalTryCatch() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 3: v8::internal::V8::FatalProcessOutOfMemory(char const*, bool) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 4: v8::internal::Factory::NewCodeRaw(int, bool) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 5: v8::internal::Factory::NewCode(v8::internal::CodeDesc const&amp;, unsigned int, v8::internal::Handle&lt;v8::internal::Object&gt;, bool, int) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 6: v8::internal::CodeGenerator::MakeCodeEpilogue(v8::internal::TurboAssembler*, v8::internal::EhFrameWriter*, v8::internal::CompilationInfo*, v8::internal::Handle&lt;v8::internal::Object&gt;) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 7: v8::internal::compiler::CodeGenerator::FinalizeCode() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 8: v8::internal::compiler::PipelineImpl::FinalizeCode() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line"> 9: v8::internal::compiler::PipelineCompilationJob::FinalizeJobImpl() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">10: v8::internal::Compiler::FinalizeCompilationJob(v8::internal::CompilationJob*) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">11: v8::internal::OptimizingCompileDispatcher::InstallOptimizedFunctions() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">12: v8::internal::StackGuard::HandleInterrupts() [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">13: v8::internal::Runtime_StackGuard(int, v8::internal::Object**, v8::internal::Isolate*) [/usr/local/lib/node_modules/node/bin//node]</span><br><span class="line">14: 0x305174e042fd</span><br><span class="line">15: 0x305175bbd919</span><br></pre></td></tr></table></figure></p><p>这样的错误信息，不要慌张，这种通用类型的最简单，搜索下就好。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>大概就是编译慢了，node认为我们有内存泄漏了。所以这个时候我们只要通过- -max-old-space-size=4096 这个来解决我们的问题即可。这个修改在node_modules/.bin下面有个ng文件。然后我们修改这个文件。</p><p>在头部的#!/usr/bin/env node之后加上- -max-old-space-size=4096就可以解决我们的问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当angular项目比较庞大的时候，打包时间就会比较慢。然后这个时候会出现&lt;br&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="问题篇" scheme="http://blog.fedfans.com/categories/%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
    
      <category term="Angular" scheme="http://blog.fedfans.com/tags/Angular/"/>
    
      <category term="编译报错" scheme="http://blog.fedfans.com/tags/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>服务器安装maven环境</title>
    <link href="http://blog.fedfans.com//page/article/42/"/>
    <id>http://blog.fedfans.com//page/article/42/</id>
    <published>2018-07-11T13:47:29.000Z</published>
    <updated>2018-08-31T14:43:08.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>由于我现在server端使用springboot进行开发，所以maven编译这步肯定必不可少。</p><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><p>打开maven官网：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>然后拷贝下载地址，去服务器上面wget下来。</p><p>然后使用tar zxvf <strong><em>.tar.gz包，然后ln -s apache-maven-</em></strong> apache-maven创建软连接，方便升级</p><p>然后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/home/software/apache-maven</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>然后我们执行mvn -v查看下我们的maven环境是否正确。</p><p>至此我们maven已经安装完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;由于我现在server端使用springboot进行开发，所以maven编译这步肯定必不可少。&lt;/p&gt;
&lt;h2 id=&quot;二、
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="Maven" scheme="http://blog.fedfans.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>服务器安装node环境</title>
    <link href="http://blog.fedfans.com//page/article/41/"/>
    <id>http://blog.fedfans.com//page/article/41/</id>
    <published>2018-07-11T12:17:06.000Z</published>
    <updated>2018-08-31T14:43:23.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>我们的服务器上面，前端代码或者写nodejs的时候，我们需要安装nodejs。有几种方法可以安装，推荐使用官网下载nodejs的版本。</p><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><p>方法一：（不推荐，因为安装的版本比较旧）</p><p>使用yum install nodejs</p><p>方法二：（推荐）</p><p>1、 从官网进行下载稳定版本的nodejs，官网地址：</p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><p>2、然后下载linux 二进制文件。</p><p>然后服务器上面使用</p><p>wget 下载地址（这个地址是右键得到下载地址）</p><p>3、然后下载到的是tar.xz包</p><p>然后我们使用解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz -d ***.tar.xz</span><br></pre></td></tr></table></figure></p><p>然后会变成.tar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf ***.tar</span><br></pre></td></tr></table></figure></p><p>然后就解压完成了。</p><p>4、然后可以创建一个软连接，方便以后升级,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s node-**** node</span><br></pre></td></tr></table></figure></p><p>5、然后我们vim /etc/profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_HOME=/home/software/node(此处是大家放在那个路径)</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin</span><br></pre></td></tr></table></figure><p>6、然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>7、我们确认下我们的环境是否安装好了，执行node -v 和npm -v</p><p>方法三：（方法一般）</p><p>下载源码包，也是方法二的地址，然后./configure &amp;&amp; make &amp;&amp; make install，请确保有安装环境的一些工具。新的服务器一般用方法二比较好。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>前面三种方法，个人还是建议使用方法二，也不麻烦。如果自己电脑环境比较全，那方法三也很快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;我们的服务器上面，前端代码或者写nodejs的时候，我们需要安装nodejs。有几种方法可以安装，推荐使用官网下载nodej
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="NodeJS" scheme="http://blog.fedfans.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的gitlab服务以及gitlab-ci的开发模式</title>
    <link href="http://blog.fedfans.com//page/article/39/"/>
    <id>http://blog.fedfans.com//page/article/39/</id>
    <published>2018-07-10T05:13:20.000Z</published>
    <updated>2018-08-31T14:53:42.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>本地我自己肯定是搭建了自己的gitlab仓库的。这次主要是出于gitlab-ci的考虑，想要在把原本自己的ci流程，从本地的jenkins转义到gitlab-ci上，只需要提交代码，就能部署到我自己的服务器上面，并且希望是能区分预发布服和线上服两种环境，本地就当开发环境了。测试环境就不搞了，预发布就当测试环境用好了。所以本次目的，就是在自己的阿里云上面搭建自己的gitlab服务，域名就选择使用gitlab.fedfans.com这个域名好了。</p><h2 id="二、搭建过程"><a href="#二、搭建过程" class="headerlink" title="二、搭建过程"></a>二、搭建过程</h2><p>搭建过程主要涉及到几步：</p><ul><li>docker环境搭建（因为拿的是新的一台阿里云机器）</li><li>gitlab docker镜像运行</li><li>然后gitlab-ci的runner搭建</li><li>测试整个gitlab-ci的流程</li></ul><p>第一步：</p><p>docker官方提供了centos环境里面怎么安装docker。<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p>第二步:</p><p>gitlab官方提供了如果使用docker安装gitlab的环境。</p><p>第三步:</p><p>3.1 根据环境安装gitlab runner, <a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/</a></p><p>3.2 然后使用linux的安装方法。<a href="https://docs.gitlab.com/runner/install/linux-manually.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/install/linux-manually.html</a></p><p>3.3 然后我们使用gitlab-runner register</p><p>他会提示我们输入gitlab地址，这个在项目的CI/CD pipelines上面有个url和token我们分别输入到gitlab-runner register中，同时使用shell模式</p><p>3.4 然后会在当前这个目录下生成一个config.toml文件</p><p>3.5 我们修改这个config.toml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 1修改为concurrent=8</span><br></pre></td></tr></table></figure><p>3.6 然后我们使用这个shell脚本进行启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line"># chkconfig: - 99 01</span><br><span class="line"># description: GitLab Runner</span><br><span class="line"># processname: /usr/bin/gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">name=&quot;yydbhz&quot;</span><br><span class="line">desc=&quot;yydbhz&quot;</span><br><span class="line">user=&quot;&quot;</span><br><span class="line">cmd=/home/root/.gitlab-runner/gitlab-runner</span><br><span class="line">args=&quot; &quot;run&quot; &quot;--working-directory&quot; &quot;/home/root/.gitlab-runner&quot; &quot;--config&quot; &quot;/home/root/.gitlab-runner/config.toml&quot; &quot;--service&quot; &quot;gitlab-runner&quot;  &quot;--syslog&quot;&quot;</span><br><span class="line">lockfile=/home/root/.gitlab-runner/$name</span><br><span class="line">pidfile=/home/root/.gitlab-runner/$name.pid</span><br><span class="line"></span><br><span class="line"># Source networking configuration.</span><br><span class="line">[ -r /etc/sysconfig/$name ] &amp;&amp; . /etc/sysconfig/$name</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    echo -n $&quot;Starting $desc: &quot;</span><br><span class="line">    daemon \</span><br><span class="line">         \</span><br><span class="line">         \</span><br><span class="line">        &quot;$cmd $args &lt;/dev/null &gt;/dev/null 2&gt;/dev/null &amp; echo \$! &gt; $pidfile&quot;</span><br><span class="line">    retval=$?</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile</span><br><span class="line">    echo</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping $desc: &quot;</span><br><span class="line">    killproc -p $pidfile $cmd -TERM</span><br><span class="line">    retval=$?</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile</span><br><span class="line">    rm -f $pidfile</span><br><span class="line">    echo</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $desc: &quot;</span><br><span class="line">    killproc -p $pidfile $cmd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">force_reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status -p $pidfile $cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || exit 7</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>然后我们使用这个脚本进行启动。</p><p>最终gitlab-ci搭建完毕。</p><p>然后gitlab-ci的使用，我们后面讲解下。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>jenkins的流程，用了不少时间了，关于工程化个人也是比较熟练了。然后本次呢主要想要更快更敏捷的开发，同时在ci的流程中比如将部署还能选择预发布和线上这种区分，所以很方便，虽然放到阿里云服务器，带来的是上传代码变慢，这个总能解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;本地我自己肯定是搭建了自己的gitlab仓库的。这次主要是出于gitlab-ci的考虑，想要在把原本自己的ci流程，从本地的
      
    
    </summary>
    
      <category term="工程化" scheme="http://blog.fedfans.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Gitlab" scheme="http://blog.fedfans.com/tags/Gitlab/"/>
    
      <category term="工程化" scheme="http://blog.fedfans.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>服务器资源有限，所以给服务器配置下swap</title>
    <link href="http://blog.fedfans.com//page/article/40/"/>
    <id>http://blog.fedfans.com//page/article/40/</id>
    <published>2018-07-10T05:13:20.000Z</published>
    <updated>2018-08-31T14:45:11.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我们的服务器资源比较有限，所以我们需要节约资源，swap能让我们机器发挥更大的作用，否则分分钟报表。</p><p>文档：</p><p><a href="https://help.aliyun.com/knowledge_detail/42534.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/42534.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;我们的服务器资源比较有限，所以我们需要节约资源，swap能让我们机器发挥更大的作用，否则分分钟报表。&lt;/p&gt;
&lt;p&gt;文档：&lt;
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Swap" scheme="http://blog.fedfans.com/tags/Swap/"/>
    
      <category term="环境搭建" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于let sencrypt过期的问题处理</title>
    <link href="http://blog.fedfans.com//page/article/38/"/>
    <id>http://blog.fedfans.com//page/article/38/</id>
    <published>2018-06-25T15:46:44.000Z</published>
    <updated>2018-08-31T14:57:03.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题介绍"><a href="#一、问题介绍" class="headerlink" title="一、问题介绍"></a>一、问题介绍</h2><p>由于当前站点的https采用的是let sencrpt，let sencrpt是每90天需要认证一下，然后最近发现我的https过期了，然后在服务器上面执行我的续期脚本，也报错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./letsencrypt-auto certonly --renew-by-default --email hzjinbing@163.com -d www.520stone.com</span><br></pre></td></tr></table></figure></p><p>然后报错内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line"></span><br><span class="line">How would you like to authenticate with the ACME CA?</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">1: Apache Web Server plugin - Beta (apache)</span><br><span class="line">2: Nginx Web Server plugin - Alpha (nginx)</span><br><span class="line">3: Spin up a temporary webserver (standalone)</span><br><span class="line">4: Place files in webroot directory (webroot)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Select the appropriate number [1-4] then [enter] (press &apos;c&apos; to cancel): 2</span><br><span class="line">Plugins selected: Authenticator nginx, Installer None</span><br><span class="line">Renewing an existing certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">tls-sni-01 challenge for www.520stone.com</span><br><span class="line">Waiting for verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line">Failed authorization procedure. www.520stone.com (tls-sni-01): urn:acme:error:unauthorized :: The client lacks sufficient authorization :: Incorrect validation certificate for tls-sni-01 challenge. Requested 8b01252f05bfcb35a2d586933f89613e.d6b3afaf871b282ab64f7c74c0886f2f.acme.invalid from 139.196.95.206:443. Received 2 certificate(s), first certificate had names &quot;www.520stone.com&quot;</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - The following errors were reported by the server:</span><br><span class="line"></span><br><span class="line">   Domain: www.520stone.com</span><br><span class="line">   Type:   unauthorized</span><br><span class="line">   Detail: Incorrect validation certificate for tls-sni-01 challenge.</span><br><span class="line">   Requested</span><br><span class="line">   8b01252f05bfcb35a2d586933f89613e.d6b3afaf871b282ab64f7c74c0886f2f.acme.invalid</span><br><span class="line">   from 139.196.95.206:443. Received 2 certificate(s), first</span><br><span class="line">   certificate had names &quot;www.520stone.com&quot;</span><br><span class="line"></span><br><span class="line">   To fix these errors, please make sure that your domain name was</span><br><span class="line">   entered correctly and the DNS A/AAAA record(s) for that domain</span><br><span class="line">   contain(s) the right IP address.</span><br></pre></td></tr></table></figure><p>所以报错已经在这边了，我们就需要解决他，否则当前博客本来好不容易积累的每天的dau就降下来了。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>当前还未解决，最近记录下这个解决过程。</p><p>最终阿里云服务器上面过了几天后，我使用下面这个代码最终续期成功了。先记录下这个脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">../code/letsencrypt/letsencrypt-auto certonly --renew-by-default --email hzjinbing@163.com -d www.520stone.com</span><br></pre></td></tr></table></figure><p>然后最终我是使用nginx，所以中间有一个项，选择2是nginx，然后回车后最终续期成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、问题介绍&quot;&gt;&lt;a href=&quot;#一、问题介绍&quot; class=&quot;headerlink&quot; title=&quot;一、问题介绍&quot;&gt;&lt;/a&gt;一、问题介绍&lt;/h2&gt;&lt;p&gt;由于当前站点的https采用的是let sencrpt，let sencrpt是每90天需要认证一下，然后最
      
    
    </summary>
    
      <category term="服务器配置" scheme="http://blog.fedfans.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="服务器" scheme="http://blog.fedfans.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="环境配置" scheme="http://blog.fedfans.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>（maven系列）编写第一个maven插件</title>
    <link href="http://blog.fedfans.com//page/article/37/"/>
    <id>http://blog.fedfans.com//page/article/37/</id>
    <published>2018-06-13T12:37:13.000Z</published>
    <updated>2018-08-31T15:06:04.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近在做接口管理平台的事情，接口管理平台的方案，采用后端java项目集成swagger，然后将swagger离线化部署到接口管理平台上。然后前端在这个平台上，可以查看后端定义的接口，同时平台上提供对应的mock数据，还可以根据这个接口生成前端的sdk，不需要再去关心ajax那块。当后端接口变动的时候，我们只需要生成新的前端的SDK。</p><p>然后问题是，为了能让后端项目不需要改动，想法：如果到了class级别肯定已经无法获取到其中的javadoc的注释了，那想的时候，就是要么做一个maven的plugin，要么做一个intellij的插件。所以本文先做技术积累，做一个maven的插件试试。</p><h2 id="二、maven插件开发入门"><a href="#二、maven插件开发入门" class="headerlink" title="二、maven插件开发入门"></a>二、maven插件开发入门</h2><p>第一步：</p><p>通过intellij idea新建一个maven工程</p><p>第二步：</p><p>修改pom.xml文件，将packaging设置为maven-plugin</p><p>第三步：</p><p>我们平常执行的mvn <strong>*</strong>的操作，我们其实在执行Mojo，</p><p>所以我们新建我们第一个MoJo，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@goal</span> buildinfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@phase</span>  pre-integration-test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildInfoMojo</span> <span class="keyword">extends</span> <span class="title">AbstractMojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@parameter</span> expression="$&#123;project&#125;"</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MavenProject mavenProject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@parameter</span> expression="$&#123;buildinfo.prefix&#125;"</span></span><br><span class="line"><span class="comment">     * default-value="+++"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现其中接口类里面的execute函数，此处我们打印一下我们执行mvn时候，代码路径和输出的路径，和测试代码路径和测试结果输出的路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;</span><br><span class="line">    Build build = mavenProject.getBuild();</span><br><span class="line">    String outputDirectory = build.getOutputDirectory();</span><br><span class="line">    String sourceDirectory = build.getSourceDirectory();</span><br><span class="line">    String testOutputDirectory = build.getTestOutputDirectory();</span><br><span class="line">    String testSourceDirectory = build.getTestSourceDirectory();</span><br><span class="line">    getLog().info(<span class="string">"\n==============\n Project build info."</span>);</span><br><span class="line"></span><br><span class="line">    String[] info = &#123;outputDirectory, sourceDirectory, testOutputDirectory, testSourceDirectory&#125;;</span><br><span class="line">    <span class="keyword">for</span>(String item: info)&#123;</span><br><span class="line">        getLog().info(<span class="string">"\t"</span>  + <span class="string">"   "</span> + item);</span><br><span class="line">    &#125;</span><br><span class="line">    getLog().info(<span class="string">"============="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编写完毕后，我们本地通过mvn clean install安装到本地的maven环境中。</p><p>然后就此我们已经编写完一个最简单的maven插件了。</p><p>第四步：测试下我们的插件：</p><p>通过执行mvn {groupId}:{artifactId}:{version}:buildinfo</p><p>最终我们可以看到下面这样的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Building demo-maven-plugin <span class="number">1.0</span>-SNAPSHOT</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- demo-maven-plugin:<span class="number">1.0</span>-SNAPSHOT:buildinfo (<span class="keyword">default</span>-cli) @ demo-maven-plugin ---</span><br><span class="line">[INFO] </span><br><span class="line">==============</span><br><span class="line"> Project build info.</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/target/classes</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/src/main/java</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/target/test-classes</span><br><span class="line">[INFO]     /Users/stone-jin/code/local/java/demo-maven-plugin/src/test/java</span><br><span class="line">[INFO] =============</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">0.488</span> s</span><br><span class="line">[INFO] Finished at: <span class="number">2018</span>-<span class="number">06</span>-<span class="number">13</span>T20:<span class="number">13</span>:<span class="number">55</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">9</span>M/<span class="number">245</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>就此我们第一个maven插件书写完毕</p><p>然后我们再将我们的maven插件发布到maven仓库中，这个发布，可以通过查看：<a href="https://www.520stone.com/page/article/34" target="_blank" rel="noopener">https://www.520stone.com/page/article/34</a></p><p>最后我们新建一个springboot的工程测试下：</p><p>放在pom包里面的build里面的plugins里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">   &lt;groupId&gt;com.netease.mail&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;demo-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>然后我们再执行下我们的maven的操作，完美可以运行</p><p>同时我们可以在intellij idea右边有个maven project中，里面有个plugins可以看到我们写的buildinfo的插件在那里。</p><p>三、结束语<br>最近好久没有写文章，哈哈哈，写起来~</p><p>这个代码放在：<a href="https://github.com/stone-jin/demo-maven-plugins" target="_blank" rel="noopener">https://github.com/stone-jin/demo-maven-plugins</a> 上了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;最近在做接口管理平台的事情，接口管理平台的方案，采用后端java项目集成swagger，然后将swagger离线化部署到接口
      
    
    </summary>
    
      <category term="后端" scheme="http://blog.fedfans.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="JAVA" scheme="http://blog.fedfans.com/tags/JAVA/"/>
    
      <category term="MAVEN" scheme="http://blog.fedfans.com/tags/MAVEN/"/>
    
  </entry>
  
</feed>
